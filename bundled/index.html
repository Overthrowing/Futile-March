<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0a0a0f">
    <meta name="description" content="Push the boulder up the mountain. A raymarching game inspired by the myth of Sisyphus.">
    <title>Sisyphus</title>
    <style>
        /* Fullscreen */
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        @supports (padding: env(safe-area-inset-bottom)) {
            body { padding-bottom: env(safe-area-inset-bottom); }
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #0a0a0f;
            font-family: 'Courier New', monospace;
        }
        canvas {
            position: absolute;
            height: 100%;
            width: 100%;
        }
        #progress {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            color: #d4af37;
            z-index: 100;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            pointer-events: none;
        }
        #message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 22px;
            color: #d4af37;
            text-align: center;
            z-index: 100;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.7);
            pointer-events: none;
            max-width: 80%;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        #message.show { opacity: 1; }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #888;
            font-size: 13px;
            z-index: 100;
            text-align: center;
            pointer-events: none;
        }
        #reset-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(212, 175, 55, 0.2);
            border: 2px solid #d4af37;
            color: #d4af37;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            z-index: 170;
            transition: all 0.2s ease;
            touch-action: manipulation;
        }
        #reset-btn:hover {
            background: rgba(212, 175, 55, 0.4);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.5);
        }
        #title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a0f 0%, #1a1020 50%, #0a0a0f 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            cursor: pointer;
        }
        #title-screen h1 {
            font-size: 72px;
            color: #d4af37;
            text-shadow: 0 0 30px rgba(212, 175, 55, 0.5);
            margin-bottom: 20px;
            letter-spacing: 8px;
        }
        #title-screen p {
            color: #888;
            font-size: 18px;
            margin-bottom: 40px;
        }
        #title-screen .start {
            color: #d4af37;
            font-size: 24px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .hidden { display: none !important; }

        /* Mobile Controls Container */
        #mobile-controls {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 150;
            pointer-events: none;
        }

        /* Fullscreen look zone (behind other controls) */
        #look-zone {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            touch-action: none;
            z-index: 140;
        }

        /* Left joystick area */
        #joystick-zone {
            position: fixed;
            left: 20px;
            bottom: 30px;
            width: 130px;
            height: 130px;
            border-radius: 50%;
            background: rgba(212, 175, 55, 0.15);
            border: 2px solid rgba(212, 175, 55, 0.4);
            pointer-events: auto;
            touch-action: none;
            z-index: 160;
        }
        #joystick-knob {
            position: absolute;
            width: 55px;
            height: 55px;
            border-radius: 50%;
            background: rgba(212, 175, 55, 0.5);
            border: 2px solid #d4af37;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        /* Jump button */
        #jump-btn {
            position: fixed;
            right: 25px;
            bottom: 30px;
            width: 75px;
            height: 75px;
            border-radius: 50%;
            background: rgba(212, 175, 55, 0.2);
            border: 3px solid #d4af37;
            color: #d4af37;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            touch-action: none;
            user-select: none;
            z-index: 160;
        }
        #jump-btn.active {
            background: rgba(212, 175, 55, 0.5);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.6);
        }

        /* Mobile instructions */
        #mobile-instructions {
            position: fixed;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(136, 136, 136, 0.6);
            font-size: 10px;
            text-align: center;
            z-index: 165;
            pointer-events: none;
            white-space: nowrap;
        }

        /* Hide desktop instructions on mobile */
        @media (max-width: 900px), (pointer: coarse) {
            #instructions { display: none !important; }
            #reset-btn {
                top: 15px;
                right: 15px;
                padding: 6px 12px;
                font-size: 11px;
            }
            #progress {
                font-size: 16px;
                top: 15px;
                left: 15px;
            }
            #message { font-size: 18px; }
        }

        /* Hide mobile controls on desktop */
        @media (min-width: 901px) and (pointer: fine) {
            #mobile-controls { display: none !important; }
            #mobile-instructions { display: none !important; }
            #look-zone { display: none !important; }
        }
    </style>
</head>
<body>
    <div id="title-screen">
        <h1>SISYPHUS</h1>
        <p>One must imagine Sisyphus happy.</p>
        <div class="start">Click to Begin</div>
    </div>
    <div id="progress" class="hidden">Height: 0m</div>
    <div id="message"></div>
    <button id="reset-btn" class="hidden">RESET (R)</button>
    <div id="instructions" class="hidden">
        WASD - Move | SPACE - Jump | Hold near boulder to push | R - Reset
    </div>

    <!-- Mobile Controls -->
    <div id="look-zone" class="hidden"></div>
    <div id="mobile-controls" class="hidden">
        <div id="joystick-zone">
            <div id="joystick-knob"></div>
        </div>
        <div id="jump-btn">JUMP</div>
    </div>
    <div id="mobile-instructions" class="hidden">
        Drag anywhere to look | Left stick to move
    </div>

        <!-- Load everything from sisyphus/ -->
    <script>
    /* === inlined from ../sisyphus/libs.js === */
// GLSL Libraries for raymarching
let libs = 
`
// Smooth minimum for organic blending
float smin(float a, float b, float k) {
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * k * 0.25;
}

// Bending transformation
vec3 bend(vec3 p, float k) {
    float c = cos(k * p.x);
    float s = sin(k * p.x);
    mat2 m = mat2(c, -s, s, c);
    return vec3(m * p.xy, p.z);
}

// Rotation around arbitrary axis
vec3 rotAxis(vec3 p, float a, vec3 u) {
    mat3 m = mat3(
        cos(a) + u.x*u.x*(1.-cos(a)), u.x*u.y*(1.-cos(a))-u.z*sin(a), u.x*u.z*(1.-cos(a)) + u.y*sin(a),
        u.y*u.x*(1.-cos(a))+u.z*sin(a), cos(a) + u.y*u.y*(1.-cos(a)), u.y*u.z*(1.-cos(a))-u.x*sin(a),
        u.z*u.x*(1.-cos(a))-u.y*sin(a), u.z*u.y*(1.-cos(a))+u.x*sin(a), cos(a) + u.z*u.z*(1.-cos(a)) 
    );
    return m * p;
}

vec3 rotY(vec3 v, float a) {
    return vec3(v.x*cos(a)+v.z*sin(a), v.y, -v.x*sin(a) + v.z*cos(a));
}

vec3 rotX(vec3 v, float a) {
    return vec3(v.x, v.y*cos(a)-v.z*sin(a), v.y*sin(a)+v.z*cos(a));
}

vec3 rotZ(vec3 v, float a) {
    return vec3(v.x*cos(a)-v.y*sin(a), v.x*sin(a)+v.y*cos(a), v.z);
}

vec3 twist(vec3 p, float k) {
    float c = cos(k * p.y);
    float s = sin(k * p.y);
    mat2 m = mat2(c, -s, s, c);
    return vec3(m * p.xz, p.y);
}

float dot2(in vec3 v) { return dot(v, v); }

// SDF Primitives
float sdBox(vec3 p, vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdCapsule(vec3 p, vec3 a, vec3 b, float r) {
    vec3 pa = p - a, ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * h) - r;
}

float sdTorus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

float sdCylinder(vec3 p, float h, float r) {
    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

float sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2) {
    vec3 ba = b - a;
    float l2 = dot(ba, ba);
    float rr = r1 - r2;
    float a2 = l2 - rr * rr;
    float il2 = 1.0 / l2;
    vec3 pa = p - a;
    float y = dot(pa, ba);
    float z = y - l2;
    float x2 = dot2(pa * l2 - ba * y);
    float y2 = y * y * l2;
    float z2 = z * z * l2;
    float k = sign(rr) * rr * rr * x2;
    if(sign(z) * a2 * z2 > k) return sqrt(x2 + z2) * il2 - r2;
    if(sign(y) * a2 * y2 < k) return sqrt(x2 + y2) * il2 - r1;
    return (sqrt(x2 * a2 * il2) + y * rr) * il2 - r1;
}

// Noise functions
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }

float noise(vec3 p) {
    vec3 a = floor(p);
    vec3 d = p - a;
    d = d * d * (3.0 - 2.0 * d);
    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
    vec4 k1 = permute(b.xyxy);
    vec4 k2 = permute(k1.xyxy + b.zzww);
    vec4 c = k2 + a.zzzz;
    vec4 k3 = permute(c);
    vec4 k4 = permute(c + 1.0);
    vec4 o1 = fract(k3 * (1.0 / 41.0));
    vec4 o2 = fract(k4 * (1.0 / 41.0));
    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
    return o4.y * d.y + o4.x * (1.0 - d.y);
}

float fbm(vec3 p) {
    float f = 0.0;
    f += 0.5 * noise(p); p *= 2.01;
    f += 0.25 * noise(p); p *= 2.02;
    f += 0.125 * noise(p); p *= 2.03;
    f += 0.0625 * noise(p);
    return f / 0.9375;
}

// Stars background
vec3 nmzHash33(vec3 q) {
    uvec3 p = uvec3(ivec3(q));
    p = p * uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;
    p = p.yzx * (p.zxy ^ (p >> 3U));
    return vec3(p ^ (p >> 16U)) * (1.0 / vec3(0xffffffffU));
}

vec3 stars(in vec3 p) {
    vec3 c = vec3(0.);
    float resX = 400.;
    for(float i = 0.; i < 4.; i++) {
        vec3 q = fract(p * (.15 * resX)) - 0.5;
        vec3 id = floor(p * (.15 * resX));
        vec2 rn = nmzHash33(id).xy;
        float c2 = 1. - smoothstep(0., .6, length(q));
        c2 *= step(rn.x, .0005 + i * 0.002);
        c += c2 * (mix(vec3(1.0, 0.49, 0.1), vec3(0.75, 0.9, 1.), rn.y) * 0.25 + 0.75);
        p *= 1.4;
    }
    return c * c * 0.5;
}
`;

let libsAfterDe = `
vec3 grad(vec3 p) {
    float eps = 0.01;
    return normalize(vec3(
        (de(p + vec3(eps, 0., 0.)) - de(p - vec3(eps, 0., 0.))) / (2. * eps),
        (de(p + vec3(0., eps, 0.)) - de(p - vec3(0., eps, 0.))) / (2. * eps),
        (de(p + vec3(0., 0., eps)) - de(p - vec3(0., 0., eps))) / (2. * eps)
    ));
}

float ao(vec3 p, vec3 n) {
    float occ = 0.0;
    float sca = 1.0;
    for(int i = 0; i < 5; i++) {
        float h = 0.01 + 0.12 * float(i) / 4.0;
        float d = de(p + h * n);
        occ += (h - d) * sca;
        sca *= 0.95;
    }
    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
}
`;

// JavaScript math utilities
function rotY(v, a) {
    return [v[0]*Math.cos(a) + v[2]*Math.sin(a), v[1], -v[0]*Math.sin(a) + v[2]*Math.cos(a)];
}

function rotX(v, a) {
    return [v[0], v[1]*Math.cos(a) - v[2]*Math.sin(a), v[1]*Math.sin(a) + v[2]*Math.cos(a)];
}

function plus(a1, a2) {
    return [a1[0] + a2[0], a1[1] + a2[1], a1[2] + a2[2]];
}

function times(a, s) {
    return [a[0]*s, a[1]*s, a[2]*s];
}

function min(...args) { return Math.min(...args); }
function max(...args) { return Math.max(...args); }

function abs(x) {
    if(Array.isArray(x)) return x.map(Math.abs);
    return Math.abs(x);
}

function cos(x) {
    if(Array.isArray(x)) return x.map(Math.cos);
    return Math.cos(x);
}

function sin(x) {
    if(Array.isArray(x)) return x.map(Math.sin);
    return Math.sin(x);
}

function len(v) { return Math.hypot(...v); }

function normalize(v) {
    const l = len(v);
    return l === 0 ? [0, 0, 0] : times(v, 1/l);
}

function dot(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }

function cross(a, b) {
    return [
        a[1]*b[2] - a[2]*b[1],
        a[2]*b[0] - a[0]*b[2],
        a[0]*b[1] - a[1]*b[0]
    ];
}

function reflect(d, n) {
    return plus(d, times(n, -2 * dot(d, n)));
}

function lerp(a, b, w) {
    if(Array.isArray(a)) {
        return a.map((v, i) => v + (b[i] - v) * w);
    }
    return a + (b - a) * w;
}

function sinLerp(a, b, w) {
    return lerp(a, b, Math.sin(Math.PI * (w - 0.5)) / 2 + 0.5);
}

function clamp(x, minVal, maxVal) {
    return Math.min(Math.max(x, minVal), maxVal);
}

function I() { return [[1,0,0], [0,1,0], [0,0,1]]; }

function matTimes(m, v) {
    return [
        m[0][0]*v[0] + m[0][1]*v[1] + m[0][2]*v[2],
        m[1][0]*v[0] + m[1][1]*v[1] + m[1][2]*v[2],
        m[2][0]*v[0] + m[2][1]*v[1] + m[2][2]*v[2]
    ];
}

function matTimesMat(a, b) {
    let temp = [[], [], []];
    for(let i = 0; i < 3; i++) {
        let col = matTimes(a, [b[0][i], b[1][i], b[2][i]]);
        for(let j = 0; j < 3; j++) {
            temp[j].push(col[j]);
        }
    }
    return temp;
}

function rotAxisMat(a, u) {
    const c = Math.cos(a), s = Math.sin(a);
    return [
        [c + u[0]*u[0]*(1-c), u[0]*u[1]*(1-c) - u[2]*s, u[0]*u[2]*(1-c) + u[1]*s],
        [u[1]*u[0]*(1-c) + u[2]*s, c + u[1]*u[1]*(1-c), u[1]*u[2]*(1-c) - u[0]*s],
        [u[2]*u[0]*(1-c) - u[1]*s, u[2]*u[1]*(1-c) + u[0]*s, c + u[2]*u[2]*(1-c)]
    ];
}

function sdBox3(p, b) {
    let q = plus(abs(p), times(b, -1));
    return len([max(q[0], 0), max(q[1], 0), max(q[2], 0)]) + min(max(q[0], q[1], q[2]), 0);
}

function dirFromAngle(ax, ay) {
    let dir = [0, 0, 1];
    dir = rotX(dir, -ay);
    dir = rotY(dir, ax);
    return dir;
}

// Mountain height function (used in both JS and GLSL)
function getMountainHeight(x, z) {
    // Main slope going up in Z direction
    const baseHeight = z * 0.3;
    // Add some waviness
    const wave = Math.sin(x * 0.1) * 2 + Math.sin(z * 0.05) * 3;
    return Math.max(0, baseHeight + wave);
}

// Slope angle at position
function getSlopeAngle(z) {
    return Math.atan(0.3); // Approximately 16.7 degrees
}

// Check if position is on the path
function isOnPath(x, z) {
    const pathWidth = 6;
    return Math.abs(x) < pathWidth;
}

function deNormal(p) {
    const eps = 0.01;
    return normalize([
        de(plus(p, [eps, 0, 0])) - de(plus(p, [-eps, 0, 0])),
        de(plus(p, [0, eps, 0])) - de(plus(p, [0, -eps, 0])),
        de(plus(p, [0, 0, eps])) - de(plus(p, [0, 0, -eps]))
    ]);
}

// Bumpy section height for physics
function getBumpyHeight(x, z) {
    let bumps = 0;
    
    // Bumpy zone 1: z = 20-28
    if (z > 18 && z < 30 && Math.abs(x) < 5) {
        const fade = smoothstepJS(18, 20, z) * smoothstepJS(30, 28, z);
        bumps += Math.sin(x * 3) * Math.sin(z * 3) * 0.15 * fade;
    }
    
    // Bumpy zone 2: z = 50-58
    if (z > 48 && z < 60 && Math.abs(x) < 5) {
        const fade = smoothstepJS(48, 50, z) * smoothstepJS(60, 58, z);
        bumps += Math.sin(x * 4 + 1) * Math.sin(z * 4) * 0.2 * fade;
    }
    
    // Bumpy zone 3: z = 95-103
    if (z > 93 && z < 105 && Math.abs(x) < 5) {
        const fade = smoothstepJS(93, 95, z) * smoothstepJS(105, 103, z);
        bumps += Math.sin(x * 5 + 2) * Math.sin(z * 5) * 0.18 * fade;
    }
    
    return bumps;
}

function smoothstepJS(edge0, edge1, x) {
    const t = clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * (3 - 2 * t);
}

// Mountain height for physics - must match GLSL mountainHeight!
function getTerrainHeight(x, z) {
    const baseHeight = z * 0.3;
    const wave = Math.sin(x * 0.1) * 2 + Math.sin(z * 0.05) * 3;
    const bumps = getBumpyHeight(x, z);
    return Math.max(-5, baseHeight + wave + bumps);
}

// Simple noise approximation for terrain detail
function simpleNoise(x, z) {
    return Math.sin(x * 1.3 + z * 0.7) * Math.cos(x * 0.9 - z * 1.1) * 0.5;
}

    </script>
    <script>
    /* === inlined from ../sisyphus/animation.js === */
function Animator(uniforms, interp) {
    this.uniforms = uniforms;
    this.interp = interp || lerp;
    this.states = [];
    this.state = -1;
    this.stateT = 0;
    this.totalStateT = 0;
    this.stateFrames = [];
    this.t = 0;
    this.totalAnimTime = 0;
    this.keyFrames = [];

    this.addKeyFrame = (nodes, t, state) => {
        if(this.states[state] === undefined) {
            this.states[state] = { keyFrames: [], totalAnimTime: 0 };
        }
        this.states[state].keyFrames.push({ nodes, t });
        if(t > this.states[state].totalAnimTime) {
            this.states[state].totalAnimTime = t;
        }
        if(this.states.length === 1) {
            this.keyFrames = this.states[state].keyFrames;
            this.totalAnimTime = this.states[state].totalAnimTime;
        }
    };

    this.currentPos = () => this.getPos(this.t);

    this.setState = (state, changeT) => {
        if(this.state !== state) {
            this.state = state;
            this.t = 0;
            this.stateFrames = [this.getPos(this.t)];
            this.keyFrames = this.states[state].keyFrames;
            this.totalAnimTime = this.states[state].totalAnimTime;
            this.stateT = changeT;
            this.totalStateT = changeT;
            this.stateFrames.push(this.keyFrames[0].nodes);
        }
    };

    this.getPos = (time) => {
        if(this.stateT <= 0) {
            if(this.keyFrames.length === 1) {
                return this.keyFrames[0].nodes;
            }
            time %= this.totalAnimTime;

            let index = 0;
            if(time > this.keyFrames[this.keyFrames.length - 2].t) {
                index = this.keyFrames.length - 2;
            } else {
                while(time >= this.keyFrames[index].t) {
                    index++;
                }
                index--;
            }

            let nodePositions = [];
            for(let i in this.keyFrames[index].nodes) {
                nodePositions.push(this.interp(
                    this.keyFrames[index].nodes[i],
                    this.keyFrames[index + 1].nodes[i],
                    (time - this.keyFrames[index].t) / (this.keyFrames[index + 1].t - this.keyFrames[index].t)
                ));
            }
            return nodePositions;
        } else {
            this.stateT -= dt;
            let nodePositions = [];
            for(let i in this.stateFrames[0]) {
                nodePositions.push(this.interp(
                    this.stateFrames[0][i],
                    this.stateFrames[1][i],
                    1 - (this.stateT / this.totalStateT)
                ));
            }
            this.t = 0;
            return nodePositions;
        }
    };

    this.update = () => {
        this.t += dt;
        let nodePositions = this.getPos(this.t);
        for(let i in this.uniforms) {
            renderer.setUni(this.uniforms[i], nodePositions[i]);
        }
    };
}

    </script>
    <script>
    /* === inlined from ../sisyphus/rendering.js === */
function createGraphics(de, colors, otherfunctions, uniforms) {
    let c = document.createElement("canvas");
    let scale = 1;
    
    c.width = scale * window.innerWidth;
    c.height = scale * window.innerHeight;
    document.body.appendChild(c);

    c.onclick = () => c.requestPointerLock();

    let gl = c.getContext("webgl2");

    function makeShader(src, type) {
        let shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if(gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            return shader;
        } else {
            console.log(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
        }
    }

    function createProgram(vertShad, fragShad) {
        let program = gl.createProgram();
        gl.attachShader(program, vertShad);
        gl.attachShader(program, fragShad);
        gl.linkProgram(program);
        return program;
    }

    let vertSrc = 
    `#version 300 es
    in vec4 a_position;
    out vec4 pos4;
    void main() {
        pos4 = a_position;
        gl_Position = a_position;
    }`;

    let fragSrc = 
    `#version 300 es
    #define MIN_DIST 0.002
    #define MAX_ITERATIONS 120
    #define RANGE 500.

    precision highp float;

    out vec4 color;
    in vec4 pos4;

    uniform vec2 res;
    uniform vec3 camPos;
    uniform vec2 camAngle;
    uniform float t;
    uniform vec3 playerPos;
    uniform vec3 boulderPos;
    uniform mat3 boulderRotMat;
    uniform vec2 playerAngle;
    uniform float isPushing;
    uniform float gameState;
    ${uniforms}

    ${libs}

    ${de}

    ${libsAfterDe}

    ${otherfunctions}

    void main() {
        vec2 pos = pos4.xy;
        pos.x *= res.x / res.y;

        float fovX = 0.4;
        float fovY = 0.4;

        vec3 dir = normalize(vec3(pos.x * fovX, pos.y * fovY, 0.6));
        dir = rotX(dir, -camAngle.y);
        dir = rotY(dir, camAngle.x);

        vec3 p = camPos;
        float dist = de(p);
        float totDist = dist;
        float glowDist = boulderGlow(p);
        float minGlow = glowDist;

        for(int i = 0; i < MAX_ITERATIONS; i++) {
            if(dist < MIN_DIST || totDist > RANGE) break;
            p += dir * dist;
            dist = de(p);
            glowDist = boulderGlow(p);
            if(glowDist < minGlow) minGlow = glowDist;
            totDist += dist;
        }

        ${colors}
    }`;

    let vertShad = makeShader(vertSrc, gl.VERTEX_SHADER);
    let fragShad = makeShader(fragSrc, gl.FRAGMENT_SHADER);

    let program = createProgram(vertShad, fragShad);

    let posLoc = gl.getAttribLocation(program, "a_position");
    let posBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,-1,1,1,1,1,1,1,-1,-1,-1]), gl.STATIC_DRAW);

    let va = gl.createVertexArray();
    gl.bindVertexArray(va);
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    gl.viewport(0, 0, c.width, c.height);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(program);

    return { gl, program, c };
}

function Renderer(de, colors, otherfunctions, uniforms) {
    let graphics = createGraphics(de, colors, otherfunctions, uniforms);
    this.gl = graphics.gl;
    this.canvas = graphics.c;
    this.program = graphics.program;
    this.uniforms = {};

    this.addUniform = (name, type, value) => {
        if(Array.isArray(value) && !Array.isArray(value[0])) {
            value = new Float32Array(value);
        }
        let uni = { location: "", t: type, name: name, value: value };
        uni.location = this.gl.getUniformLocation(this.program, name);
        
        if(type === "vec2") uni.t = (loc, val) => this.gl.uniform2fv(loc, val);
        if(type === "vec3") uni.t = (loc, val) => this.gl.uniform3fv(loc, val);
        if(type === "vec4") uni.t = (loc, val) => this.gl.uniform4fv(loc, val);
        if(type === "float") uni.t = (loc, val) => this.gl.uniform1f(loc, val);
        if(type === "mat3") uni.t = (loc, val) => {
            let temp = [];
            for(let i of val) {
                for(let j of i) temp.push(j);
            }
            this.gl.uniformMatrix3fv(loc, false, new Float32Array(temp));
        };

        this.uniforms[name] = uni;
        uni.t(uni.location, uni.value);
    };

    this.setUni = (name, value) => {
        if(Array.isArray(value) && !Array.isArray(value[0])) {
            value = new Float32Array(value);
        }
        this.uniforms[name].value = value;
        this.uniforms[name].t(this.uniforms[name].location, value);
    };

    this.draw = () => {
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    };
}

    </script>
    <script>
    /* === inlined from ../sisyphus/graphics.js === */
let renderer = new Renderer(

// Distance estimation function (de)
`
// Mountain terrain height - must match JS getTerrainHeight!
float mountainHeight(vec3 p) {
    float baseSlope = p.z * 0.3;
    float wave = sin(p.x * 0.1) * 2.0 + sin(p.z * 0.05) * 3.0;
    float height = baseSlope + wave;
    return max(-5.0, height);
}

// Bumpy sections - adds small bumps in certain areas
float bumpySection(vec3 p) {
    float bumps = 0.0;
    
    // Bumpy zone 1: z = 20-28
    if(p.z > 18.0 && p.z < 30.0 && abs(p.x) < 5.0) {
        float fade = smoothstep(18.0, 20.0, p.z) * smoothstep(30.0, 28.0, p.z);
        bumps += sin(p.x * 3.0) * sin(p.z * 3.0) * 0.15 * fade;
    }
    
    // Bumpy zone 2: z = 50-58
    if(p.z > 48.0 && p.z < 60.0 && abs(p.x) < 5.0) {
        float fade = smoothstep(48.0, 50.0, p.z) * smoothstep(60.0, 58.0, p.z);
        bumps += sin(p.x * 4.0 + 1.0) * sin(p.z * 4.0) * 0.2 * fade;
    }
    
    // Bumpy zone 3: z = 95-103
    if(p.z > 93.0 && p.z < 105.0 && abs(p.x) < 5.0) {
        float fade = smoothstep(93.0, 95.0, p.z) * smoothstep(105.0, 103.0, p.z);
        bumps += sin(p.x * 5.0 + 2.0) * sin(p.z * 5.0) * 0.18 * fade;
    }
    
    return bumps;
}

// The main mountain/ground
float mountain(vec3 p) {
    float h = mountainHeight(p);
    
    // Add visual rocky texture (doesn't affect collision height)
    float rocky = fbm(p * 0.15) * 0.3;
    
    // Add bumpy sections
    float bumps = bumpySection(p);
    
    float ground = p.y - h - rocky - bumps;
    
    // Carve out the path
    float pathWidth = 6.0;
    float pathDepth = 0.5;
    float pathDist = abs(p.x);
    float pathCarve = smoothstep(pathWidth, pathWidth - 1.0, pathDist) * pathDepth;
    
    return ground + pathCarve;
}

// Spinning bar obstacle - tilted to match slope
float spinningBar(vec3 p, vec3 barPos, float barAngle) {
    vec3 q = p - barPos;
    
    // Tilt the whole thing to match the slope (about 16.7 degrees = atan(0.3))
    float slopeAngle = 0.29; // atan(0.3)
    q = rotX(q, slopeAngle);
    q = rotY(q, barAngle);
    
    // Horizontal bar
    float bar = sdCapsule(q, vec3(-4.0, 0.0, 0.0), vec3(4.0, 0.0, 0.0), 0.3);
    // Central pole (perpendicular to slope)
    float pole = sdCylinder(q, 3.0, 0.2);
    
    return min(bar, pole);
}

// Floor beam - small beam lying across the path
float floorBeam(vec3 p, vec3 beamPos, float width) {
    vec3 q = p - beamPos;
    // Tilt to match slope
    q = rotX(q, 0.29);
    // Beam lying across (X direction)
    return sdBox(q, vec3(width, 0.15, 0.3));
}

// Hole/pit in the ground
float hole(vec3 p, vec3 holePos, float radius) {
    vec2 d = vec2(length(p.xz - holePos.xz) - radius, p.y - holePos.y);
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}

// The boulder with carved grooves like jackrabbit
float boulderRings(vec3 p) {
    float rad = 2.0;
    float ringThickness = 0.2;
    
    vec3 r1P = twist(p, 0.2);
    float ring1 = sdTorus(r1P, vec2(rad, ringThickness));
    
    vec3 r2P = rotY(p, 1.047);
    r2P = twist(r2P, 0.2);
    float ring2 = sdTorus(r2P, vec2(rad, ringThickness));
    
    vec3 r3P = rotY(p, 2.094);
    r3P = twist(r3P, 0.2);
    float ring3 = sdTorus(r3P, vec2(rad, ringThickness));
    
    return min(min(ring1, ring2), ring3);
}

float boulder(vec3 p) {
    if(length(p - boulderPos) > 4.0) {
        return sdSphere(p - boulderPos, 2.5);
    }
    vec3 q = p - boulderPos;
    q = boulderRotMat * q;
    
    float sphere = sdSphere(q, 2.5);
    float rings = boulderRings(q);
    
    return max(sphere, -rings);
}

float boulderSimple(vec3 p) {
    return sdSphere(p - boulderPos, 2.5);
}

// Sisyphus character
float playerHead(vec3 p) {
    p -= uHeadPos;
    float head = sdSphere(p - vec3(0.0, 0.4, 0.0), 0.2);
    float nose = sdSphere(p - vec3(0.0, 0.37, 0.18), 0.08);
    
    // Beard
    float beard = sdRoundCone(p, vec3(0.0, 0.25, 0.1), vec3(0.0, 0.1, 0.05), 0.12, 0.08);
    
    float d = smin(head, nose, 0.1);
    d = smin(d, beard, 0.08);
    return d;
}

float playerBody(vec3 p) {
    vec3 chestP = p + uChestPos;
    float torso = sdRoundCone(chestP, vec3(0.0, 0.15, 0.0), vec3(0.0, -0.15, -0.1), 0.2, 0.12);
    
    // Arms extended forward for pushing
    float pushOffset = isPushing * 0.15;
    vec3 armR = vec3(0.15, 0.1 - pushOffset, 0.2 + pushOffset);
    vec3 armL = vec3(-0.15, 0.1 - pushOffset, 0.2 + pushOffset);
    
    float rArm = sdCapsule(chestP, vec3(0.2, 0.1, 0.0), armR, 0.05);
    float lArm = sdCapsule(chestP, vec3(-0.2, 0.1, 0.0), armL, 0.05);
    
    float d = torso;
    d = min(d, rArm);
    d = min(d, lArm);
    return d;
}

float playerLegs(vec3 p) {
    vec3 hip1 = uhip1;
    vec3 jr1 = ujr1;
    vec3 jr2 = ujr2;
    vec3 jr3 = ujr3;
    vec3 hip2 = uhip2;
    vec3 jl1 = ujl1;
    vec3 jl2 = ujl2;
    vec3 jl3 = ujl3;

    float thigh1 = sdCapsule(p, hip1, jr1, 0.04);
    float shin1 = sdCapsule(p, jr1, jr2, 0.035);
    float foot1 = sdCapsule(p, jr2, jr3, 0.03);

    float thigh2 = sdCapsule(p, hip2, jl1, 0.04);
    float shin2 = sdCapsule(p, jl1, jl2, 0.035);
    float foot2 = sdCapsule(p, jl2, jl3, 0.03);

    float d = min(thigh1, shin1);
    d = min(d, foot1);
    d = min(d, thigh2);
    d = min(d, shin2);
    d = min(d, foot2);
    return d;
}

float player(vec3 p) {
    vec3 q = p - playerPos;
    if(length(q) > 1.5) {
        return sdSphere(q, 1.0);
    }
    q = rotY(q, -playerAngle.x);
    
    vec3 bodyP = rotX(q, uBodyAngle.y);
    
    float head = playerHead(bodyP);
    float body = playerBody(bodyP);
    float legs = playerLegs(q);
    
    return min(min(head, body), legs);
}

// All spinning bars - aligned with terrain
float allSpinningBars(vec3 p) {
    float d = 1000.0;
    
    // Bar 1 at z=30
    float h1 = mountainHeight(vec3(0.0, 0.0, 30.0)) + 1.5;
    d = min(d, spinningBar(p, vec3(0.0, h1, 30.0), t * 1.5));
    
    // Bar 2 at z=60
    float h2 = mountainHeight(vec3(0.0, 0.0, 60.0)) + 1.5;
    d = min(d, spinningBar(p, vec3(0.0, h2, 60.0), -t * 2.0));
    
    // Bar 3 at z=90
    float h3 = mountainHeight(vec3(0.0, 0.0, 90.0)) + 1.5;
    d = min(d, spinningBar(p, vec3(0.0, h3, 90.0), t * 1.2 + 1.57));
    
    // Bar 4 at z=120
    float h4 = mountainHeight(vec3(0.0, 0.0, 120.0)) + 1.5;
    d = min(d, spinningBar(p, vec3(0.0, h4, 120.0), -t * 1.8 + 0.785));
    
    return d;
}

// All holes - aligned with terrain
float allHoles(vec3 p) {
    float d = 1000.0;
    
    // Hole 1
    float h1 = mountainHeight(vec3(2.5, 0.0, 45.0)) - 5.0;
    vec3 holePos1 = vec3(2.5, h1, 45.0);
    float hole1 = length(p.xz - holePos1.xz) - 3.0;
    if(p.y < holePos1.y + 5.0) {
        d = min(d, max(hole1, -(p.y - holePos1.y)));
    }
    
    // Hole 2
    float h2 = mountainHeight(vec3(-2.0, 0.0, 75.0)) - 5.0;
    vec3 holePos2 = vec3(-2.0, h2, 75.0);
    float hole2 = length(p.xz - holePos2.xz) - 2.5;
    if(p.y < holePos2.y + 5.0) {
        d = min(d, max(hole2, -(p.y - holePos2.y)));
    }
    
    // Hole 3
    float h3 = mountainHeight(vec3(1.5, 0.0, 105.0)) - 5.0;
    vec3 holePos3 = vec3(1.5, h3, 105.0);
    float hole3 = length(p.xz - holePos3.xz) - 2.0;
    if(p.y < holePos3.y + 5.0) {
        d = min(d, max(hole3, -(p.y - holePos3.y)));
    }
    
    return d;
}

// Tilted box - aligned with slope
float tiltedBox(vec3 p, vec3 boxPos, vec3 size) {
    vec3 q = p - boxPos;
    q = rotX(q, 0.29); // Tilt to match slope
    return sdBox(q, size);
}

// Random boxes scattered on the path - tilted to match slope
float allBoxes(vec3 p) {
    float d = 1000.0;
    
    // Box 1 - left side at z=15
    vec3 boxPos1 = vec3(-3.0, mountainHeight(vec3(-3.0, 0.0, 15.0)) + 1.0, 15.0);
    d = min(d, tiltedBox(p, boxPos1, vec3(1.0, 1.0, 1.0)));
    
    // Box 2 - right side at z=25
    vec3 boxPos2 = vec3(2.5, mountainHeight(vec3(2.5, 0.0, 25.0)) + 0.75, 25.0);
    d = min(d, tiltedBox(p, boxPos2, vec3(0.75, 0.75, 0.75)));
    
    // Box 3 - center-left at z=40
    vec3 boxPos3 = vec3(-1.5, mountainHeight(vec3(-1.5, 0.0, 40.0)) + 1.2, 40.0);
    d = min(d, tiltedBox(p, boxPos3, vec3(1.2, 1.2, 0.8)));
    
    // Box 4 - right at z=55
    vec3 boxPos4 = vec3(3.5, mountainHeight(vec3(3.5, 0.0, 55.0)) + 0.9, 55.0);
    d = min(d, tiltedBox(p, boxPos4, vec3(0.9, 0.9, 1.1)));
    
    // Box 5 - left at z=70
    vec3 boxPos5 = vec3(-4.0, mountainHeight(vec3(-4.0, 0.0, 70.0)) + 1.5, 70.0);
    d = min(d, tiltedBox(p, boxPos5, vec3(1.5, 1.5, 1.0)));
    
    // Box 6 - center-right at z=85
    vec3 boxPos6 = vec3(1.0, mountainHeight(vec3(1.0, 0.0, 85.0)) + 0.8, 85.0);
    d = min(d, tiltedBox(p, boxPos6, vec3(0.8, 0.8, 0.8)));
    
    // Box 7 - left at z=100
    vec3 boxPos7 = vec3(-2.5, mountainHeight(vec3(-2.5, 0.0, 100.0)) + 1.1, 100.0);
    d = min(d, tiltedBox(p, boxPos7, vec3(1.1, 1.1, 0.9)));
    
    // Box 8 - right at z=115
    vec3 boxPos8 = vec3(4.0, mountainHeight(vec3(4.0, 0.0, 115.0)) + 1.3, 115.0);
    d = min(d, tiltedBox(p, boxPos8, vec3(1.3, 1.0, 1.2)));
    
    // Box 9 - center at z=130
    vec3 boxPos9 = vec3(0.5, mountainHeight(vec3(0.5, 0.0, 130.0)) + 0.7, 130.0);
    d = min(d, tiltedBox(p, boxPos9, vec3(0.7, 0.7, 0.7)));
    
    // Box 10 - left at z=140
    vec3 boxPos10 = vec3(-3.5, mountainHeight(vec3(-3.5, 0.0, 140.0)) + 1.0, 140.0);
    d = min(d, tiltedBox(p, boxPos10, vec3(1.0, 1.0, 1.0)));
    
    return d;
}

// Floor beams - small obstacles on the ground
float allFloorBeams(vec3 p) {
    float d = 1000.0;
    
    // Beam 1 at z=10
    vec3 beamPos1 = vec3(0.0, mountainHeight(vec3(0.0, 0.0, 10.0)) + 0.15, 10.0);
    d = min(d, floorBeam(p, beamPos1, 4.0));
    
    // Beam 2 at z=35
    vec3 beamPos2 = vec3(-1.0, mountainHeight(vec3(-1.0, 0.0, 35.0)) + 0.15, 35.0);
    d = min(d, floorBeam(p, beamPos2, 3.5));
    
    // Beam 3 at z=52
    vec3 beamPos3 = vec3(1.5, mountainHeight(vec3(1.5, 0.0, 52.0)) + 0.15, 52.0);
    d = min(d, floorBeam(p, beamPos3, 3.0));
    
    // Beam 4 at z=68
    vec3 beamPos4 = vec3(0.0, mountainHeight(vec3(0.0, 0.0, 68.0)) + 0.15, 68.0);
    d = min(d, floorBeam(p, beamPos4, 4.5));
    
    // Beam 5 at z=82
    vec3 beamPos5 = vec3(-0.5, mountainHeight(vec3(-0.5, 0.0, 82.0)) + 0.15, 82.0);
    d = min(d, floorBeam(p, beamPos5, 3.5));
    
    // Beam 6 at z=98
    vec3 beamPos6 = vec3(0.5, mountainHeight(vec3(0.5, 0.0, 98.0)) + 0.15, 98.0);
    d = min(d, floorBeam(p, beamPos6, 4.0));
    
    // Beam 7 at z=112
    vec3 beamPos7 = vec3(-1.0, mountainHeight(vec3(-1.0, 0.0, 112.0)) + 0.15, 112.0);
    d = min(d, floorBeam(p, beamPos7, 3.0));
    
    // Beam 8 at z=125
    vec3 beamPos8 = vec3(0.0, mountainHeight(vec3(0.0, 0.0, 125.0)) + 0.15, 125.0);
    d = min(d, floorBeam(p, beamPos8, 5.0));
    
    return d;
}

float boulderGlow(vec3 p) {
    return boulderSimple(p);
}

float de(vec3 p) {
    float ground = mountain(p);
    
    // Carve holes into ground
    float holes = allHoles(p);
    ground = max(ground, -holes);
    
    float bars = allSpinningBars(p);
    float boxes = allBoxes(p);
    float beams = allFloorBeams(p);
    float bould = boulder(p);
    float plyr = player(p);
    
    float d = ground;
    d = min(d, bars);
    d = min(d, boxes);
    d = min(d, beams);
    d = min(d, bould);
    d = min(d, plyr);
    
    return d;
}
`,

// Color/shading
`
vec3 col = vec3(0.0);
vec3 skyCol = vec3(0.02, 0.01, 0.05);

if(dist <= MIN_DIST) {
    vec3 norm = grad(p);
    float occ = ao(p, norm);
    
    vec3 lightDir = normalize(vec3(0.5, 0.8, -0.3));
    vec3 lightDir2 = normalize(vec3(-0.3, 0.5, 0.5));
    float diff = max(dot(norm, lightDir), 0.0);
    float diff2 = max(dot(norm, lightDir2), 0.0) * 0.3;
    
    // Mountain/ground
    if(mountain(p) < 0.01) {
        vec3 rockCol = vec3(0.25, 0.2, 0.18);
        float n = fbm(p * 2.0);
        rockCol = mix(rockCol, vec3(0.35, 0.3, 0.25), n);
        
        // Path is slightly different color
        float pathGlow = smoothstep(6.0, 4.0, abs(p.x));
        rockCol = mix(rockCol, vec3(0.4, 0.35, 0.3), pathGlow * 0.3);
        
        col = rockCol * (0.3 + diff * 0.5 + diff2) * occ;
        
        // Height-based fog
        float heightFog = smoothstep(0.0, 50.0, p.y);
        col = mix(col, col * vec3(0.8, 0.85, 1.0), heightFog * 0.3);
    }
    
    // Spinning bars
    else if(allSpinningBars(p) < 0.01) {
        vec3 metalCol = vec3(0.6, 0.55, 0.5);
        float spec = pow(max(dot(reflect(-lightDir, norm), normalize(camPos - p)), 0.0), 32.0);
        col = metalCol * (0.4 + diff * 0.4) + vec3(spec * 0.3);
        
        // Danger glow
        col += vec3(0.8, 0.2, 0.1) * (0.2 + 0.1 * sin(t * 5.0));
    }
    
    // Boxes
    else if(allBoxes(p) < 0.01) {
        // Weathered stone/wood color
        vec3 boxCol = vec3(0.45, 0.38, 0.32);
        float n = noise(p * 5.0);
        boxCol = mix(boxCol, vec3(0.55, 0.48, 0.4), n);
        
        // Edge highlighting
        float edgeFactor = 1.0 - smoothstep(0.0, 0.1, allBoxes(p + norm * 0.05));
        boxCol += vec3(0.1) * edgeFactor;
        
        col = boxCol * (0.4 + diff * 0.5 + diff2 * 0.2) * occ;
    }
    
    // Floor beams
    else if(allFloorBeams(p) < 0.01) {
        // Dark wood color
        vec3 woodCol = vec3(0.3, 0.22, 0.15);
        float woodGrain = sin(p.x * 20.0 + noise(p * 3.0) * 5.0) * 0.5 + 0.5;
        woodCol = mix(woodCol, vec3(0.4, 0.3, 0.2), woodGrain * 0.3);
        
        col = woodCol * (0.5 + diff * 0.4) * occ;
    }
    
    // Boulder
    else if(boulder(p) < 0.01) {
        vec3 q = p - boulderPos;
        q = boulderRotMat * q;
        
        vec3 stoneCol = vec3(0.5, 0.45, 0.4);
        float n = fbm(q * 0.5);
        stoneCol = mix(stoneCol, vec3(0.6, 0.55, 0.5), n);
        
        col = stoneCol * (0.4 + diff * 0.5 + diff2 * 0.3) * occ;
        
        // Ring grooves glow
        float ringDist = boulderRings(q);
        if(ringDist < 0.5) {
            col += vec3(0.9, 0.7, 0.3) * (0.5 - ringDist) * (0.5 + 0.5 * sin(t * 2.0));
        }
        
        // Glow when being pushed
        col += vec3(0.8, 0.6, 0.2) * isPushing * 0.3;
    }
    
    // Player (Sisyphus)
    else if(player(p) < 0.01) {
        vec3 q = p - playerPos;
        q = rotY(q, -playerAngle.x);
        vec3 bodyP = rotX(q, uBodyAngle.y);
        
        // Skin tone for Sisyphus
        vec3 skinCol = vec3(0.7, 0.55, 0.45);
        
        if(playerHead(bodyP) < 0.01) {
            col = skinCol * (0.5 + diff * 0.4);
            // Eyes
            float eyeR = sdSphere(bodyP - uHeadPos - vec3(0.08, 0.45, 0.12), 0.03);
            float eyeL = sdSphere(bodyP - uHeadPos - vec3(-0.08, 0.45, 0.12), 0.03);
            if(min(eyeR, eyeL) < 0.01) {
                col = vec3(0.1);
            }
        }
        else if(playerBody(bodyP) < 0.01) {
            // Simple cloth/toga
            vec3 clothCol = vec3(0.75, 0.7, 0.6);
            col = clothCol * (0.4 + diff * 0.5);
            
            // Strain effect when pushing
            col = mix(col, vec3(0.8, 0.5, 0.4), isPushing * 0.2);
        }
        else {
            // Legs - skin
            col = skinCol * (0.5 + diff * 0.4);
        }
    }
    
    // Distance fog
    float fog = 1.0 - exp(-totDist * 0.003);
    col = mix(col, skyCol, fog);
    
} else {
    // Sky with stars
    col = stars(dir) + skyCol;
    
    // Subtle gradient
    col += vec3(0.1, 0.05, 0.15) * (1.0 - abs(dir.y));
}

// Boulder glow bloom effect
float glowIntensity = 0.4 / (1.0 + minGlow * minGlow * 0.5);
col += vec3(0.9, 0.7, 0.3) * glowIntensity * 0.15;

// Vignette
vec2 uv = pos4.xy;
float vig = 1.0 - 0.3 * length(uv);
col *= vig;

// Tone mapping
col = col / (1.0 + col);
col = pow(col, vec3(0.9));

color = vec4(col, 1.0);
`,

// Additional functions
`
`,

// Uniforms
`
uniform vec3 uhip1;
uniform vec3 ujr1;
uniform vec3 ujr2;
uniform vec3 ujr3;
uniform vec3 uhip2;
uniform vec3 ujl1;
uniform vec3 ujl2;
uniform vec3 ujl3;
uniform vec3 uChestPos;
uniform vec3 uHeadPos;
uniform float uLift;
uniform vec3 uBodyAngle;
`
);

// Box obstacle positions - must match GLSL!
const boxObstacles = [
    { x: -3.0, z: 15, sx: 1.0, sy: 1.0, sz: 1.0 },
    { x: 2.5, z: 25, sx: 0.75, sy: 0.75, sz: 0.75 },
    { x: -1.5, z: 40, sx: 1.2, sy: 1.2, sz: 0.8 },
    { x: 3.5, z: 55, sx: 0.9, sy: 0.9, sz: 1.1 },
    { x: -4.0, z: 70, sx: 1.5, sy: 1.5, sz: 1.0 },
    { x: 1.0, z: 85, sx: 0.8, sy: 0.8, sz: 0.8 },
    { x: -2.5, z: 100, sx: 1.1, sy: 1.1, sz: 0.9 },
    { x: 4.0, z: 115, sx: 1.3, sy: 1.0, sz: 1.2 },
    { x: 0.5, z: 130, sx: 0.7, sy: 0.7, sz: 0.7 },
    { x: -3.5, z: 140, sx: 1.0, sy: 1.0, sz: 1.0 }
];

// Floor beam positions - must match GLSL!
const floorBeams = [
    { x: 0.0, z: 10, width: 4.0 },
    { x: -1.0, z: 35, width: 3.5 },
    { x: 1.5, z: 52, width: 3.0 },
    { x: 0.0, z: 68, width: 4.5 },
    { x: -0.5, z: 82, width: 3.5 },
    { x: 0.5, z: 98, width: 4.0 },
    { x: -1.0, z: 112, width: 3.0 },
    { x: 0.0, z: 125, width: 5.0 }
];

// JavaScript distance estimation for physics
function de(p) {
    // Simple terrain height check
    const terrainY = getTerrainHeight(p[0], p[2]);
    let ground = p[1] - terrainY;
    
    // Check spinning bars
    const bars = deSpinningBars(p);
    
    // Check boxes
    const boxes = deBoxes(p);
    
    // Check floor beams
    const beams = deFloorBeams(p);
    
    // Check holes
    const holes = deHoles(p);
    
    // Carve holes
    ground = Math.max(ground, -holes);
    
    return Math.min(ground, Math.min(bars, Math.min(boxes, beams)));
}

function deSpinningBars(p) {
    let d = Infinity;
    const barPositions = [
        { z: 30, speed: 1.5, offset: 0 },
        { z: 60, speed: -2.0, offset: 0 },
        { z: 90, speed: 1.2, offset: Math.PI/2 },
        { z: 120, speed: -1.8, offset: Math.PI/4 }
    ];
    
    for (const bar of barPositions) {
        // Use terrain height for bar position
        const h = getTerrainHeight(0, bar.z) + 1.5;
        const barPos = [0, h, bar.z];
        const angle = t * bar.speed + bar.offset;
        
        // Distance to bar
        const q = plus(p, times(barPos, -1));
        const rotated = rotY(q, angle);
        
        // Capsule distance
        const barDist = sdCapsule3D(rotated, [-4, 0, 0], [4, 0, 0], 0.3);
        const poleDist = sdCylinder3D(rotated, 3, 0.2);
        
        d = Math.min(d, Math.min(barDist, poleDist));
    }
    
    return d;
}

function deBoxes(p) {
    let d = Infinity;
    
    for (const box of boxObstacles) {
        const h = getTerrainHeight(box.x, box.z) + box.sy;
        const boxPos = [box.x, h, box.z];
        // Tilted box - rotate point to match slope
        let q = plus(p, times(boxPos, -1));
        q = rotX(q, 0.29); // Match slope angle
        d = Math.min(d, sdBox3D(q, [box.sx, box.sy, box.sz]));
    }
    
    return d;
}

function deFloorBeams(p) {
    let d = Infinity;
    
    for (const beam of floorBeams) {
        const h = getTerrainHeight(beam.x, beam.z) + 0.15;
        const beamPos = [beam.x, h, beam.z];
        // Tilted beam - rotate point to match slope
        let q = plus(p, times(beamPos, -1));
        q = rotX(q, 0.29); // Match slope angle
        d = Math.min(d, sdBox3D(q, [beam.width, 0.15, 0.3]));
    }
    
    return d;
}

function sdBox3D(p, b) {
    const q = [Math.abs(p[0]) - b[0], Math.abs(p[1]) - b[1], Math.abs(p[2]) - b[2]];
    const outside = len([Math.max(q[0], 0), Math.max(q[1], 0), Math.max(q[2], 0)]);
    const inside = Math.min(Math.max(q[0], Math.max(q[1], q[2])), 0);
    return outside + inside;
}

function deHoles(p) {
    let d = Infinity;
    const holePositions = [
        { x: 2.5, z: 45, radius: 3.0 },
        { x: -2.0, z: 75, radius: 2.5 },
        { x: 1.5, z: 105, radius: 2.0 }
    ];
    
    for (const hole of holePositions) {
        // Use terrain height for hole depth
        const h = getTerrainHeight(hole.x, hole.z) - 5.0;
        const dx = p[0] - hole.x;
        const dz = p[2] - hole.z;
        const dist2D = Math.sqrt(dx*dx + dz*dz) - hole.radius;
        
        if (p[1] < h + 5) {
            d = Math.min(d, Math.max(dist2D, -(p[1] - h)));
        }
    }
    
    return d;
}

function sdCapsule3D(p, a, b, r) {
    const pa = plus(p, times(a, -1));
    const ba = plus(b, times(a, -1));
    const h = clamp(dot(pa, ba) / dot(ba, ba), 0, 1);
    return len(plus(pa, times(ba, -h))) - r;
}

function sdCylinder3D(p, h, r) {
    const d = [len([p[0], p[2]]) - r, Math.abs(p[1]) - h];
    return Math.min(Math.max(d[0], d[1]), 0) + len([Math.max(d[0], 0), Math.max(d[1], 0)]);
}

// Get bar collision info for knockback
function getSpinningBarForce(p) {
    const barPositions = [
        { z: 30, speed: 1.5, offset: 0 },
        { z: 60, speed: -2.0, offset: 0 },
        { z: 90, speed: 1.2, offset: Math.PI/2 },
        { z: 120, speed: -1.8, offset: Math.PI/4 }
    ];
    
    for (const bar of barPositions) {
        // Use terrain height for bar position
        const h = getTerrainHeight(0, bar.z) + 1.5;
        const barPos = [0, h, bar.z];
        const angle = t * bar.speed + bar.offset;
        
        const q = plus(p, times(barPos, -1));
        const rotated = rotY(q, angle);
        const barDist = sdCapsule3D(rotated, [-4, 0, 0], [4, 0, 0], 0.3);
        
        if (barDist < 1.0) {
            // Calculate tangential force direction
            const tangent = rotY([0, 0, 1], angle + Math.PI/2);
            const force = times(tangent, bar.speed * 15);
            force[1] = 10; // Add upward component
            return { hit: true, force };
        }
    }
    
    return { hit: false, force: [0, 0, 0] };
}

// Hole positions for player/boulder falling
const holePositions = [
    { x: 2.5, z: 45, radius: 3.0 },
    { x: -2.0, z: 75, radius: 2.5 },
    { x: 1.5, z: 105, radius: 2.0 }
];

// Check if position is over a hole
function isOverHole(x, z) {
    for (const hole of holePositions) {
        const dx = x - hole.x;
        const dz = z - hole.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist < hole.radius) {
            return true;
        }
    }
    return false;
}

// Get info about the hole the position is over
function getHoleInfo(x, z) {
    for (const hole of holePositions) {
        const dx = x - hole.x;
        const dz = z - hole.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist < hole.radius * 1.5) {
            return hole;
        }
    }
    return null;
}

    </script>
    <script>
    /* === inlined from ../sisyphus/player.js === */
let mouseDown = [];
let keyDown = [];
let keyPressed = [];

document.onmousemove = (e) => {
    if (document.pointerLockElement) {
        let sens = [1/700, 1/700];
        player.angle[0] += e.movementX * sens[0];
        player.angle[1] -= e.movementY * sens[1];
        player.angle[1] = clamp(player.angle[1], -Math.PI/2.5, Math.PI/2.5);
    }
};

document.onmousedown = (e) => mouseDown[e.button] = true;
document.onmouseup = (e) => mouseDown[e.button] = false;
document.onkeydown = (e) => {
    keyDown[e.key.toLowerCase()] = true;
    keyPressed[e.key.toLowerCase()] = true;
};
document.onkeyup = (e) => keyDown[e.key.toLowerCase()] = false;

function Player() {
    this.pos = [0, 2, -10];
    this.camPos = [0, 0, 0];
    this.angle = [0, 0];
    this.bodyAngle = [0, 0];
    
    this.gravity = 40;
    this.jumpVel = 12;
    this.speed = 5;
    this.pushSpeed = 3;
    
    this.velocity = [0, 0, 0];
    this.body2 = 0.5;
    
    this.isPushing = false;
    this.pushCooldown = 0;
    
    this.coyoteTime = 0;
    
    this.update = () => {
        this.checkSpinningBars();
        this.move();
        this.push();
        
        if (this.legAnimator) {
            this.legAnimator.update();
        }
        this.updateUniforms();
    };
    
    this.checkSpinningBars = () => {
        const barResult = getSpinningBarForce(this.pos);
        if (barResult.hit) {
            this.velocity = plus(this.velocity, barResult.force);
            showMessage("Knocked off!", 1500);
        }
    };
    
    this.move = () => {
        let vel = [0, 0, 0];
        let moveSpeed = this.isPushing ? this.pushSpeed : this.speed;
        
        if (keyDown["w"]) {
            vel[2] += Math.cos(this.angle[0]);
            vel[0] += Math.sin(this.angle[0]);
        }
        if (keyDown["s"]) {
            vel[2] -= Math.cos(this.angle[0]);
            vel[0] -= Math.sin(this.angle[0]);
        }
        if (keyDown["a"]) {
            vel[2] += Math.sin(this.angle[0]);
            vel[0] -= Math.cos(this.angle[0]);
        }
        if (keyDown["d"]) {
            vel[2] -= Math.sin(this.angle[0]);
            vel[0] += Math.cos(this.angle[0]);
        }
        
        // Update body angle to face movement direction
        if (len(vel) > 0) {
            const targetAngle = Math.atan2(vel[0], vel[2]);
            this.bodyAngle[0] = lerpAngle(this.bodyAngle[0], targetAngle, 0.1);
            renderer.setUni("playerAngle", [this.bodyAngle[0], 0]);
        }
        
        // Animation states
        if (!this.onGround()) {
            if (this.velocity[1] > 5) {
                this.legAnimator && this.legAnimator.setState(2, 0.1);
            } else {
                this.legAnimator && this.legAnimator.setState(3, 1);
            }
        } else {
            if (len(vel) > 0) {
                this.legAnimator && this.legAnimator.setState(0, 0.1);
            } else {
                this.legAnimator && this.legAnimator.setState(1, 0.2);
            }
        }
        
        // Normalize and apply speed
        if (len(vel) > 0) {
            vel = times(normalize(vel), moveSpeed * dt);
        }
        
        // Coyote time for jumping
        this.coyoteTime -= dt;
        if (this.onGround()) {
            this.coyoteTime = 0.15;
            this.velocity[0] *= 0.9;
            this.velocity[2] *= 0.9;
        }
        
        // Jump
        if (keyPressed[" "] && this.coyoteTime > 0) {
            this.velocity[1] = this.jumpVel;
            this.coyoteTime = -1;
        }
        
        // Apply gravity
        this.velocity[1] -= this.gravity * dt;
        
        // Combine movement velocity
        vel = plus(times(this.velocity, dt), vel);
        this.pos = plus(vel, this.pos);
        
        // Check if player is over a hole
        const overHole = isOverHole(this.pos[0], this.pos[2]);
        
        // Ground collision - but allow falling into holes
        const terrainY = getTerrainHeight(this.pos[0], this.pos[2]);
        const groundLevel = terrainY + this.body2;
        
        if (!overHole && this.pos[1] < groundLevel) {
            this.pos[1] = groundLevel;
            if (this.velocity[1] < 0) {
                this.velocity[1] = 0;
            }
        }
        
        // If over hole, apply extra gravity pull
        if (overHole) {
            const holeInfo = getHoleInfo(this.pos[0], this.pos[2]);
            if (holeInfo) {
                // Pull towards hole center
                const dx = holeInfo.x - this.pos[0];
                const dz = holeInfo.z - this.pos[2];
                const pullStrength = 3.0;
                this.velocity[0] += dx * pullStrength * dt;
                this.velocity[2] += dz * pullStrength * dt;
            }
        }
        
        // Spinning bar collision (handled separately)
        const barDist = deSpinningBars(this.pos);
        if (barDist < this.body2) {
            // Push away from bar
            const pushDir = deNormal(this.pos);
            this.pos = plus(this.pos, times(pushDir, this.body2 - barDist));
        }
        
        // Box collision
        const boxDist = deBoxes(this.pos);
        if (boxDist < this.body2) {
            // Find push direction from box
            const eps = 0.05;
            const boxNorm = normalize([
                deBoxes(plus(this.pos, [eps, 0, 0])) - deBoxes(plus(this.pos, [-eps, 0, 0])),
                deBoxes(plus(this.pos, [0, eps, 0])) - deBoxes(plus(this.pos, [0, -eps, 0])),
                deBoxes(plus(this.pos, [0, 0, eps])) - deBoxes(plus(this.pos, [0, 0, -eps]))
            ]);
            this.pos = plus(this.pos, times(boxNorm, this.body2 - boxDist));
            // Stop velocity into the box
            const velDot = dot(this.velocity, boxNorm);
            if (velDot < 0) {
                this.velocity = plus(this.velocity, times(boxNorm, -velDot));
            }
        }
        
        // Floor beam collision - can step over small beams
        const beamDist = deFloorBeams(this.pos);
        if (beamDist < this.body2) {
            // Push up and over the beam
            this.pos[1] = Math.max(this.pos[1], getTerrainHeight(this.pos[0], this.pos[2]) + 0.3 + this.body2);
        }
        
        // Boulder collision - prevent clipping through the ball
        const toBoulder = plus(this.pos, times(boulder.pos, -1));
        const distToBoulder = len(toBoulder);
        const minDist = this.body2 + boulder.size;
        
        if (distToBoulder < minDist && distToBoulder > 0.01) {
            // Push player out of boulder
            const pushDir = normalize(toBoulder);
            const overlap = minDist - distToBoulder;
            this.pos = plus(this.pos, times(pushDir, overlap));
            
            // Stop velocity into boulder
            const velIntoBoulder = dot(this.velocity, times(pushDir, -1));
            if (velIntoBoulder > 0) {
                this.velocity = plus(this.velocity, times(pushDir, velIntoBoulder));
            }
        }
        
        // Keep player on path (soft boundary)
        const pathWidth = 6.5;
        if (Math.abs(this.pos[0]) > pathWidth) {
            this.pos[0] = Math.sign(this.pos[0]) * pathWidth;
            this.velocity[0] *= -0.5;
        }
        
        // Fell into hole check
        if (this.pos[1] < terrainY - 8) {
            triggerRestart("Fell into the abyss!");
        }
    };
    
    this.push = () => {
        this.pushCooldown -= dt;
        
        // Check if near boulder and moving towards it
        const toBoulder = plus(boulder.pos, times(this.pos, -1));
        const distToBoulder = len(toBoulder);
        
        // Direction player is moving
        const moveDir = dirFromAngle(this.angle[0], 0);
        const dotProduct = dot(normalize(toBoulder), moveDir);
        
        // Can push if close, moving towards boulder, and pressing forward
        const canPush = distToBoulder < 4.5 && 
                        distToBoulder > 2.0 && 
                        dotProduct > 0.5 && 
                        keyDown["w"] &&
                        this.onGround();
        
        if (canPush && this.pushCooldown <= 0) {
            this.isPushing = true;
            
            // Apply push force to boulder
            const pushDir = normalize([toBoulder[0], 0, toBoulder[2]]);
            const pushForce = 3.0;
            boulder.applyPush(times(pushDir, pushForce));
            
            // Lean forward while pushing
            renderer.setUni("uBodyAngle", [0, 0.3, 0]);
        } else {
            this.isPushing = false;
            renderer.setUni("uBodyAngle", [0, 0, 0]);
        }
        
        renderer.setUni("isPushing", this.isPushing ? 1.0 : 0.0);
    };
    
    this.onGround = () => {
        // Can't be on ground if over a hole
        if (isOverHole(this.pos[0], this.pos[2])) {
            return false;
        }
        const terrainY = getTerrainHeight(this.pos[0], this.pos[2]);
        return this.pos[1] <= terrainY + this.body2 + 0.1;
    };
    
    this.updateUniforms = () => {
        renderer.setUni("playerPos", this.pos);
        renderer.setUni("camAngle", this.angle);
        
        // Third person camera behind player
        let camDir = [0, 0, -6];
        camDir = rotX(camDir, -this.angle[1]);
        camDir = rotY(camDir, this.angle[0]);
        
        let camPos = plus(plus(this.pos, [0, 1.5, 0]), camDir);
        
        // Camera collision
        let iterations = 50;
        while (de(camPos) < 0.8 && iterations > 0) {
            iterations--;
            camPos = plus(camPos, times(normalize(camDir), -0.1));
        }
        
        renderer.setUni("camPos", camPos);
        this.camPos = camPos;
    };
    
    this.reset = (z) => {
        const terrainY = getTerrainHeight(0, z);
        this.pos = [0, terrainY + 2, z];
        this.velocity = [0, 0, 0];
        this.isPushing = false;
    };
    
    this.createAnimators = () => {
        const legUnis = [
            "uhip1", "ujr1", "ujr2", "ujr3",
            "uhip2", "ujl1", "ujl2", "ujl3",
            "uHeadPos", "uChestPos", "uBodyAngle"
        ];
        
        const legUniValues = [
            // Walking frame 1
            [
                [0.1, -0.1, -0.12],
                [0.15, -0.2, 0.15],
                [0.13, -0.35, 0.0],
                [0.13, -0.46, 0.15],
                [-0.1, -0.1, -0.12],
                [-0.15, -0.28, -0.05],
                [-0.13, -0.3, -0.2],
                [-0.13, -0.46, -0.15],
                [0, 0, 0],
                [0, 0, 0],
                [0, -0.3, 0],
                1.2
            ],
            // Idle
            [
                [0.1, -0.1, -0.12],
                [0.15, -0.26, 0.05],
                [0.13, -0.35, -0.15],
                [0.13, -0.46, 0],
                [-0.1, -0.1, -0.12],
                [-0.15, -0.26, 0.05],
                [-0.13, -0.35, -0.15],
                [-0.13, -0.46, 0],
                [0, 0, 0],
                [0, 0, 0],
                [0, 0, 0],
                1.2
            ],
            // Jump up
            [
                [0.1, -0.1, -0.12],
                [0.15, -0.18, 0.05],
                [0.13, -0.25, -0.15],
                [0.13, -0.35, 0],
                [-0.1, -0.1, -0.12],
                [-0.15, -0.18, 0.05],
                [-0.13, -0.25, -0.15],
                [-0.13, -0.35, 0],
                [0, 0, 0],
                [0, 0, 0],
                [0, -0.2, 0],
                1.2
            ],
            // Falling
            [
                [0.1, -0.1, -0.12],
                [0.15, -0.13, 0.05],
                [0.13, -0.2, -0.15],
                [0.13, -0.3, 0],
                [-0.1, -0.1, -0.12],
                [-0.15, -0.13, 0.05],
                [-0.13, -0.2, -0.15],
                [-0.13, -0.3, 0],
                [0, 0, 0],
                [0, 0, 0],
                [0, -0.2, 0],
                1.2
            ],
            // Walking frame 2
            [
                [0.1, -0.1, -0.12],
                [0.15, -0.28, -0.05],
                [0.13, -0.3, -0.2],
                [0.13, -0.46, -0.15],
                [-0.1, -0.1, -0.12],
                [-0.15, -0.2, 0.15],
                [-0.13, -0.35, 0.0],
                [-0.13, -0.46, 0.15],
                [0, 0, 0],
                [0, 0, 0],
                [0, -0.3, 0],
                1.2
            ]
        ];
        
        for (let i in legUnis) {
            renderer.addUniform(legUnis[i], "vec3", legUniValues[1][i]);
        }
        renderer.addUniform("uLift", "float", 1.2);
        
        this.legAnimator = new Animator([...legUnis, "uLift"], sinLerp);
        
        const stepTime = 0.3;
        this.legAnimator.addKeyFrame(legUniValues[0], 0, 0);
        this.legAnimator.addKeyFrame(legUniValues[4], stepTime/2, 0);
        this.legAnimator.addKeyFrame(legUniValues[0], stepTime, 0);
        
        this.legAnimator.addKeyFrame(legUniValues[1], 0, 1);
        this.legAnimator.addKeyFrame(legUniValues[2], 0, 2);
        this.legAnimator.addKeyFrame(legUniValues[3], 0, 3);
    };
    
    this.createAnimators();
}

function lerpAngle(a, b, w) {
    a = a % (2 * Math.PI);
    b = b % (2 * Math.PI);
    if (Math.abs(b - a) < Math.PI) {
        return lerp(a, b, w);
    } else {
        a += Math.sign(b - a) * 2 * Math.PI;
        return lerp(a, b, w);
    }
}

let player = new Player();

    </script>
    <script>
    /* === inlined from ../sisyphus/boulder.js === */
function Boulder() {
    this.pos = [0, 5, 0];
    this.size = 2.5;
    this.gravity = 25;
    
    this.velocity = [0, 0, 0];
    this.rotVel = 0;
    this.rotAxis = [0, 0, 1];
    this.rotMat = I();
    
    this.friction = 0.98;
    this.groundFriction = 0.995;
    this.slopeGravity = 12; // Gravity pulling boulder down the slope
    
    this.beingPushed = false;
    this.pushForce = [0, 0, 0];
    
    this.maxHeight = 0;
    
    this.update = () => {
        this.beingPushed = len(this.pushForce) > 0.1;
        
        // Apply push force
        if (this.beingPushed) {
            this.velocity = plus(this.velocity, times(this.pushForce, dt));
            this.pushForce = times(this.pushForce, 0.9); // Decay push
        }
        
        // Check collision with spinning bars
        this.checkBarCollision();
        
        // Check if fell in hole
        this.checkHoles();
        
        // Ground check and physics
        const terrainY = getTerrainHeight(this.pos[0], this.pos[2]);
        const groundY = terrainY + this.size;
        
        if (this.pos[1] <= groundY + 0.1) {
            // On ground
            this.pos[1] = groundY;
            
            // Bounce if falling fast
            if (this.velocity[1] < -5) {
                this.velocity[1] *= -0.3;
            } else {
                this.velocity[1] = 0;
            }
            
            // Apply ground friction
            this.velocity[0] *= this.groundFriction;
            this.velocity[2] *= this.groundFriction;
            
            // If NOT being pushed, gravity pulls boulder backwards (down the slope)
            if (!this.beingPushed && this.pos[2] > 0) {
                // Slope pulls boulder back
                const slopeForce = this.slopeGravity * 0.3; // 0.3 is slope angle
                this.velocity[2] -= slopeForce * dt;
                
                // Small random wobble
                this.velocity[0] += (Math.random() - 0.5) * 0.5 * dt;
            }
            
            // Update rotation based on movement
            const groundSpeed = len([this.velocity[0], this.velocity[2]]);
            if (groundSpeed > 0.1) {
                this.rotVel = groundSpeed / this.size;
                this.rotAxis = normalize(cross([this.velocity[0], 0, this.velocity[2]], [0, 1, 0]));
            }
        } else {
            // In air - apply gravity
            this.velocity[1] -= this.gravity * dt;
        }
        
        // Apply air friction
        this.velocity = times(this.velocity, this.friction);
        
        // Update position
        this.pos = plus(this.pos, times(this.velocity, dt));
        
        // Box collision
        const boxDist = deBoxes(this.pos);
        if (boxDist < this.size) {
            // Find push direction from box
            const eps = 0.1;
            const boxNorm = normalize([
                deBoxes(plus(this.pos, [eps, 0, 0])) - deBoxes(plus(this.pos, [-eps, 0, 0])),
                deBoxes(plus(this.pos, [0, eps, 0])) - deBoxes(plus(this.pos, [0, -eps, 0])),
                deBoxes(plus(this.pos, [0, 0, eps])) - deBoxes(plus(this.pos, [0, 0, -eps]))
            ]);
            this.pos = plus(this.pos, times(boxNorm, this.size - boxDist + 0.1));
            // Bounce off box
            const velDot = dot(this.velocity, boxNorm);
            if (velDot < 0) {
                this.velocity = plus(this.velocity, times(boxNorm, -velDot * 1.5));
            }
        }
        
        // Floor beam collision - boulder bumps over beams
        const beamDist = deFloorBeams(this.pos);
        if (beamDist < this.size) {
            // Find push direction from beam
            const eps = 0.1;
            const beamNorm = normalize([
                deFloorBeams(plus(this.pos, [eps, 0, 0])) - deFloorBeams(plus(this.pos, [-eps, 0, 0])),
                deFloorBeams(plus(this.pos, [0, eps, 0])) - deFloorBeams(plus(this.pos, [0, -eps, 0])),
                deFloorBeams(plus(this.pos, [0, 0, eps])) - deFloorBeams(plus(this.pos, [0, 0, -eps]))
            ]);
            this.pos = plus(this.pos, times(beamNorm, this.size - beamDist + 0.05));
            // Small bounce and slowdown
            this.velocity[1] += 2;
            this.velocity[2] *= 0.9; // Slow down when hitting beam
        }
        
        // Keep on path (soft boundaries)
        const pathWidth = 5.5;
        if (Math.abs(this.pos[0]) > pathWidth) {
            this.pos[0] = Math.sign(this.pos[0]) * pathWidth;
            this.velocity[0] *= -0.5;
        }
        
        // Prevent boulder from going below start
        if (this.pos[2] < -5) {
            this.pos[2] = -5;
            this.velocity[2] = 0;
        }
        
        // Update rotation matrix
        if (len(this.rotAxis) > 0) {
            this.rotMat = matTimesMat(rotAxisMat(this.rotVel * dt, this.rotAxis), this.rotMat);
        }
        
        // Track max height
        if (this.pos[2] > this.maxHeight) {
            this.maxHeight = this.pos[2];
        }
        
        // Check if boulder rolled too far back
        if (this.pos[2] < this.maxHeight - 30 && this.maxHeight > 10) {
            triggerRestart("The boulder escaped!");
        }
        
        this.updateUniforms();
    };
    
    this.checkBarCollision = () => {
        const barResult = getSpinningBarForce(this.pos);
        if (barResult.hit) {
            // Boulder gets knocked
            this.velocity = plus(this.velocity, times(barResult.force, 0.5));
            this.velocity[1] += 5;
        }
    };
    
    this.checkHoles = () => {
        const holePositions = [
            { x: 2.5, z: 45, radius: 3.0 },
            { x: -2.0, z: 75, radius: 2.5 },
            { x: 1.5, z: 105, radius: 2.0 }
        ];
        
        for (const hole of holePositions) {
            const dx = this.pos[0] - hole.x;
            const dz = this.pos[2] - hole.z;
            const dist = Math.sqrt(dx*dx + dz*dz);
            
            if (dist < hole.radius + this.size * 0.5) {
                // Near hole - pull towards center
                const pullStrength = 5 * (1 - dist / (hole.radius + this.size));
                this.velocity[0] -= (dx / dist) * pullStrength * dt;
                this.velocity[2] -= (dz / dist) * pullStrength * dt;
                
                if (dist < hole.radius * 0.5) {
                    // Fell in hole!
                    triggerRestart("The boulder fell into a pit!");
                }
            }
        }
    };
    
    this.applyPush = (force) => {
        this.pushForce = plus(this.pushForce, force);
    };
    
    this.updateUniforms = () => {
        renderer.setUni("boulderPos", this.pos);
        renderer.setUni("boulderRotMat", this.rotMat);
    };
    
    this.reset = (z) => {
        const terrainY = getTerrainHeight(0, z);
        this.pos = [0, terrainY + this.size + 1, z + 3];
        this.velocity = [0, 0, 0];
        this.rotMat = I();
        this.rotVel = 0;
        this.maxHeight = z;
        this.pushForce = [0, 0, 0];
    };
    
    this.de = (p) => {
        return len(plus(p, times(this.pos, -1))) - this.size;
    };
}

let boulder = new Boulder();

    </script>
    <script>
    /* === inlined from ../sisyphus/game.js === */
// Initialize uniforms
renderer.addUniform("res", "vec2", [window.innerWidth, window.innerHeight]);
renderer.addUniform("camPos", "vec3", [0, 5, -10]);
renderer.addUniform("camAngle", "vec2", [0, 0]);
renderer.addUniform("t", "float", 0);
renderer.addUniform("boulderPos", "vec3", [0, 5, 3]);
renderer.addUniform("playerPos", "vec3", [0, 2, 0]);
renderer.addUniform("playerAngle", "vec2", [0, 0]);
renderer.addUniform("boulderRotMat", "mat3", I());
renderer.addUniform("isPushing", "float", 0);
renderer.addUniform("gameState", "float", 0);

// Game state
let t = performance.now() / 1000;
let dt = 1/60;
let gameStarted = false;
let restartPending = false;
let restartMessage = "";
let messageTimeout = null;

// DOM elements
const titleScreen = document.getElementById("title-screen");
const instructions = document.getElementById("instructions");
const progressEl = document.getElementById("progress");
const messageEl = document.getElementById("message");
const resetBtn = document.getElementById("reset-btn");
const mobileControls = document.getElementById("mobile-controls");
const mobileInstructions = document.getElementById("mobile-instructions");
const joystickZone = document.getElementById("joystick-zone");
const joystickKnob = document.getElementById("joystick-knob");
const lookZone = document.getElementById("look-zone");
const jumpBtn = document.getElementById("jump-btn");

// Mobile detection
const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || window.innerWidth <= 768;

// Start game on click/touch
titleScreen.onclick = () => {
    titleScreen.classList.add("hidden");
    progressEl.classList.remove("hidden");
    instructions.classList.remove("hidden");
    resetBtn.classList.remove("hidden");
    
    if (isMobile) {
        mobileControls.classList.remove("hidden");
        mobileInstructions.classList.remove("hidden");
        lookZone.classList.remove("hidden");
    }
    
    gameStarted = true;
    
    // Reset positions
    player.reset(-10);
    boulder.reset(-10);
    
    if (!isMobile) {
        renderer.canvas.requestPointerLock();
    }
};

// Full reset function
function fullReset() {
    restartPending = false;
    player.reset(-10);
    boulder.reset(-10);
    boulder.maxHeight = 0;
    showMessage("Reset!", 1500);
}

// Reset button click
resetBtn.onclick = (e) => {
    e.stopPropagation();
    fullReset();
    if (!isMobile) {
        renderer.canvas.requestPointerLock();
    }
};

// Show message in center of screen
function showMessage(msg, duration = 2000) {
    messageEl.textContent = msg;
    messageEl.classList.add("show");
    
    if (messageTimeout) clearTimeout(messageTimeout);
    messageTimeout = setTimeout(() => {
        messageEl.classList.remove("show");
    }, duration);
}

// Trigger restart - player must walk back down
function triggerRestart(reason) {
    if (restartPending) return;
    
    restartPending = true;
    restartMessage = reason;
    showMessage(reason + " Walk back to the bottom to restart.", 5000);
    
    // Reset boulder to bottom
    boulder.reset(-5);
}

// Check if player reached bottom for restart
function checkRestart() {
    if (restartPending && player.pos[2] < 0) {
        restartPending = false;
        showMessage("Begin again...", 2000);
        boulder.reset(-5);
        boulder.maxHeight = 0;
    }
}

// Victory check
function checkVictory() {
    const victoryZ = 150;
    if (boulder.pos[2] >= victoryZ) {
        showMessage("Victory! But the boulder rolls back...", 4000);
        setTimeout(() => {
            boulder.reset(-5);
            player.reset(-10);
            boulder.maxHeight = 0;
        }, 4000);
    }
}

// Update progress display
function updateUI() {
    const height = Math.max(0, Math.floor(boulder.pos[2] * 0.3));
    const maxH = Math.max(0, Math.floor(boulder.maxHeight * 0.3));
    progressEl.textContent = `Height: ${height}m (Best: ${maxH}m)`;
}

// Main game loop
function update() {
    try {
        // Delta time
        const now = performance.now() / 1000;
        dt = Math.min(now - t, 1/20);
        t = now;
        
        if (gameStarted) {
            // Update game objects
            player.update();
            boulder.update();
            
            // Game checks
            checkRestart();
            checkVictory();
            updateUI();
        }
        
        // Update shader time
        renderer.setUni("t", t);
        
        // Render
        renderer.draw();
        
        // Reset input
        keyPressed = [];
        
    } catch (e) {
        console.error(e);
    }
    
    requestAnimationFrame(update);
}

// Handle window resize
window.onresize = () => {
    renderer.canvas.width = window.innerWidth;
    renderer.canvas.height = window.innerHeight;
    renderer.gl.viewport(0, 0, window.innerWidth, window.innerHeight);
    renderer.setUni("res", [window.innerWidth, window.innerHeight]);
};

// Handle pointer lock change (desktop only)
document.addEventListener('pointerlockchange', () => {
    if (!document.pointerLockElement && gameStarted && !isMobile) {
        showMessage("Click to resume", 1000);
    }
});

// R key for reset
document.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'r' && gameStarted) {
        fullReset();
    }
});

// ============ MOBILE CONTROLS ============

// Joystick state
let joystickActive = false;
let joystickTouchId = null;
let joystickCenter = { x: 0, y: 0 };
let joystickInput = { x: 0, y: 0 };

// Look state
let lookActive = false;
let lookTouchId = null;
let lookStart = { x: 0, y: 0 };

// Get touch by ID
function getTouchById(touches, id) {
    for (let i = 0; i < touches.length; i++) {
        if (touches[i].identifier === id) return touches[i];
    }
    return null;
}

// Joystick handlers
if (joystickZone) {
    joystickZone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (joystickTouchId === null) {
            const touch = e.changedTouches[0];
            joystickTouchId = touch.identifier;
            joystickActive = true;
            const rect = joystickZone.getBoundingClientRect();
            joystickCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
        }
    }, { passive: false });
    
    joystickZone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = getTouchById(e.touches, joystickTouchId);
        if (touch && joystickActive) {
            const dx = touch.clientX - joystickCenter.x;
            const dy = touch.clientY - joystickCenter.y;
            const maxDist = 50;
            const dist = Math.min(Math.sqrt(dx*dx + dy*dy), maxDist);
            const angle = Math.atan2(dy, dx);
            
            joystickInput.x = (dist / maxDist) * Math.cos(angle);
            joystickInput.y = (dist / maxDist) * Math.sin(angle);
            
            // Update knob position
            joystickKnob.style.left = `calc(50% + ${joystickInput.x * maxDist}px)`;
            joystickKnob.style.top = `calc(50% + ${joystickInput.y * maxDist}px)`;
            
            // Apply to keyDown for movement
            keyDown['w'] = joystickInput.y < -0.3;
            keyDown['s'] = joystickInput.y > 0.3;
            keyDown['a'] = joystickInput.x < -0.3;
            keyDown['d'] = joystickInput.x > 0.3;
        }
    }, { passive: false });
    
    const joystickEnd = (e) => {
        const touch = getTouchById(e.changedTouches, joystickTouchId);
        if (touch) {
            joystickActive = false;
            joystickTouchId = null;
            joystickInput = { x: 0, y: 0 };
            joystickKnob.style.left = '50%';
            joystickKnob.style.top = '50%';
            keyDown['w'] = false;
            keyDown['s'] = false;
            keyDown['a'] = false;
            keyDown['d'] = false;
        }
    };
    
    joystickZone.addEventListener('touchend', joystickEnd, { passive: false });
    joystickZone.addEventListener('touchcancel', joystickEnd, { passive: false });
}

// Look zone handlers
if (lookZone) {
    lookZone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (lookTouchId === null) {
            const touch = e.changedTouches[0];
            lookTouchId = touch.identifier;
            lookActive = true;
            lookStart = { x: touch.clientX, y: touch.clientY };
        }
    }, { passive: false });
    
    lookZone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = getTouchById(e.touches, lookTouchId);
        if (touch && lookActive && gameStarted) {
            const dx = touch.clientX - lookStart.x;
            const dy = touch.clientY - lookStart.y;
            
            const sens = 0.004;
            player.angle[0] += dx * sens;
            player.angle[1] -= dy * sens;
            player.angle[1] = clamp(player.angle[1], -Math.PI/2.5, Math.PI/2.5);
            
            lookStart = { x: touch.clientX, y: touch.clientY };
        }
    }, { passive: false });
    
    const lookEnd = (e) => {
        const touch = getTouchById(e.changedTouches, lookTouchId);
        if (touch) {
            lookActive = false;
            lookTouchId = null;
        }
    };
    
    lookZone.addEventListener('touchend', lookEnd, { passive: false });
    lookZone.addEventListener('touchcancel', lookEnd, { passive: false });
}

// Jump button handler
if (jumpBtn) {
    jumpBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        e.stopPropagation();
        jumpBtn.classList.add('active');
        keyPressed[' '] = true;
        keyDown[' '] = true;
    }, { passive: false });
    
    jumpBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        jumpBtn.classList.remove('active');
        keyDown[' '] = false;
    }, { passive: false });
    
    jumpBtn.addEventListener('touchcancel', () => {
        jumpBtn.classList.remove('active');
        keyDown[' '] = false;
    });
}

// Prevent default touch on canvas
renderer.canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
renderer.canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

// ============ END MOBILE CONTROLS ============

// Initial render
renderer.draw();

// Start the game loop
update();

    </script>
</body>
</html>


