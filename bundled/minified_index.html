<!doctype html><html lang=en><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black-translucent"><meta name=mobile-web-app-capable content="yes"><meta name=theme-color content="#0a0a0f"><meta name=description content="Push the boulder up the mountain. A raymarching game inspired by the myth of Sisyphus."><title>Sisyphus</title><style>html,body{height:100%;width:100%;overflow:hidden;touch-action:none;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}@supports(padding:env(safe-area-inset-bottom)){body{padding-bottom:env(safe-area-inset-bottom)}}*{margin:0;padding:0;box-sizing:border-box}body{overflow:hidden;background:#0a0a0f;font-family:courier new,monospace}canvas{position:absolute;height:100%;width:100%}#progress{position:absolute;top:20px;left:20px;font-size:24px;color:#d4af37;z-index:100;text-shadow:0 0 10px rgba(212,175,55,.5);pointer-events:none}#message{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);font-size:22px;color:#d4af37;text-align:center;z-index:100;text-shadow:0 0 20px rgba(212,175,55,.7);pointer-events:none;max-width:80%;opacity:0;transition:opacity .3s ease}#message.show{opacity:1}#instructions{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);color:#888;font-size:13px;z-index:100;text-align:center;pointer-events:none}#reset-btn{position:absolute;top:20px;right:20px;padding:10px 20px;background:rgba(212,175,55,.2);border:2px solid #d4af37;color:#d4af37;font-family:courier new,monospace;font-size:14px;cursor:pointer;z-index:170;transition:all .2s ease;touch-action:manipulation}#reset-btn:hover{background:rgba(212,175,55,.4);box-shadow:0 0 15px rgba(212,175,55,.5)}#title-screen{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(180deg,#0a0a0f 0%,#1a1020 50%,#0a0a0f 100%);display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:200;cursor:pointer}#title-screen h1{font-size:72px;color:#d4af37;text-shadow:0 0 30px rgba(212,175,55,.5);margin-bottom:20px;letter-spacing:8px}#title-screen p{color:#888;font-size:18px;margin-bottom:40px}#title-screen .start{color:#d4af37;font-size:24px;animation:pulse 2s infinite}@keyframes pulse{0%,100%{opacity:1}50%{opacity:.5}}.hidden{display:none!important}#mobile-controls{position:fixed;top:0;left:0;right:0;bottom:0;z-index:150;pointer-events:none}#look-zone{position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:auto;touch-action:none;z-index:140}#joystick-zone{position:fixed;left:20px;bottom:30px;width:130px;height:130px;border-radius:50%;background:rgba(212,175,55,.15);border:2px solid rgba(212,175,55,.4);pointer-events:auto;touch-action:none;z-index:160}#joystick-knob{position:absolute;width:55px;height:55px;border-radius:50%;background:rgba(212,175,55,.5);border:2px solid #d4af37;left:50%;top:50%;transform:translate(-50%,-50%);pointer-events:none}#jump-btn{position:fixed;right:25px;bottom:30px;width:75px;height:75px;border-radius:50%;background:rgba(212,175,55,.2);border:3px solid #d4af37;color:#d4af37;font-family:courier new,monospace;font-size:11px;font-weight:700;display:flex;align-items:center;justify-content:center;pointer-events:auto;touch-action:none;user-select:none;z-index:160}#jump-btn.active{background:rgba(212,175,55,.5);box-shadow:0 0 20px rgba(212,175,55,.6)}#mobile-instructions{position:fixed;bottom:8px;left:50%;transform:translateX(-50%);color:rgba(136,136,136,.6);font-size:10px;text-align:center;z-index:165;pointer-events:none;white-space:nowrap}@media(max-width:900px),(pointer:coarse){#instructions{display:none!important}#reset-btn{top:15px;right:15px;padding:6px 12px;font-size:11px}#progress{font-size:16px;top:15px;left:15px}#message{font-size:18px}}@media(min-width:901px) and (pointer:fine){#mobile-controls{display:none!important}#mobile-instructions{display:none!important}#look-zone{display:none!important}}</style><div id=title-screen><h1>SISYPHUS</h1><p>One must imagine Sisyphus happy.<div class=start>Click to Begin</div></div><div id=progress class=hidden>Height: 0m</div><div id=message></div><button id=reset-btn class=hidden>RESET (R)</button><div id=instructions class=hidden>WASD - Move | SPACE - Jump | Hold near boulder to push | R - Reset</div><div id=look-zone class=hidden></div><div id=mobile-controls class=hidden><div id=joystick-zone><div id=joystick-knob></div></div><div id=jump-btn>JUMP</div></div><div id=mobile-instructions class=hidden>Drag anywhere to look | Left stick to move</div><script>let libs=`
// Smooth minimum for organic blending
float smin(float a, float b, float k) {
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * k * 0.25;
}

// Bending transformation
vec3 bend(vec3 p, float k) {
    float c = cos(k * p.x);
    float s = sin(k * p.x);
    mat2 m = mat2(c, -s, s, c);
    return vec3(m * p.xy, p.z);
}

// Rotation around arbitrary axis
vec3 rotAxis(vec3 p, float a, vec3 u) {
    mat3 m = mat3(
        cos(a) + u.x*u.x*(1.-cos(a)), u.x*u.y*(1.-cos(a))-u.z*sin(a), u.x*u.z*(1.-cos(a)) + u.y*sin(a),
        u.y*u.x*(1.-cos(a))+u.z*sin(a), cos(a) + u.y*u.y*(1.-cos(a)), u.y*u.z*(1.-cos(a))-u.x*sin(a),
        u.z*u.x*(1.-cos(a))-u.y*sin(a), u.z*u.y*(1.-cos(a))+u.x*sin(a), cos(a) + u.z*u.z*(1.-cos(a)) 
    );
    return m * p;
}

vec3 rotY(vec3 v, float a) {
    return vec3(v.x*cos(a)+v.z*sin(a), v.y, -v.x*sin(a) + v.z*cos(a));
}

vec3 rotX(vec3 v, float a) {
    return vec3(v.x, v.y*cos(a)-v.z*sin(a), v.y*sin(a)+v.z*cos(a));
}

vec3 rotZ(vec3 v, float a) {
    return vec3(v.x*cos(a)-v.y*sin(a), v.x*sin(a)+v.y*cos(a), v.z);
}

vec3 twist(vec3 p, float k) {
    float c = cos(k * p.y);
    float s = sin(k * p.y);
    mat2 m = mat2(c, -s, s, c);
    return vec3(m * p.xz, p.y);
}

float dot2(in vec3 v) { return dot(v, v); }

// SDF Primitives
float sdBox(vec3 p, vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdCapsule(vec3 p, vec3 a, vec3 b, float r) {
    vec3 pa = p - a, ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * h) - r;
}

float sdTorus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

float sdCylinder(vec3 p, float h, float r) {
    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

float sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2) {
    vec3 ba = b - a;
    float l2 = dot(ba, ba);
    float rr = r1 - r2;
    float a2 = l2 - rr * rr;
    float il2 = 1.0 / l2;
    vec3 pa = p - a;
    float y = dot(pa, ba);
    float z = y - l2;
    float x2 = dot2(pa * l2 - ba * y);
    float y2 = y * y * l2;
    float z2 = z * z * l2;
    float k = sign(rr) * rr * rr * x2;
    if(sign(z) * a2 * z2 > k) return sqrt(x2 + z2) * il2 - r2;
    if(sign(y) * a2 * y2 < k) return sqrt(x2 + y2) * il2 - r1;
    return (sqrt(x2 * a2 * il2) + y * rr) * il2 - r1;
}

// Noise functions
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }

float noise(vec3 p) {
    vec3 a = floor(p);
    vec3 d = p - a;
    d = d * d * (3.0 - 2.0 * d);
    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
    vec4 k1 = permute(b.xyxy);
    vec4 k2 = permute(k1.xyxy + b.zzww);
    vec4 c = k2 + a.zzzz;
    vec4 k3 = permute(c);
    vec4 k4 = permute(c + 1.0);
    vec4 o1 = fract(k3 * (1.0 / 41.0));
    vec4 o2 = fract(k4 * (1.0 / 41.0));
    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
    return o4.y * d.y + o4.x * (1.0 - d.y);
}

float fbm(vec3 p) {
    float f = 0.0;
    f += 0.5 * noise(p); p *= 2.01;
    f += 0.25 * noise(p); p *= 2.02;
    f += 0.125 * noise(p); p *= 2.03;
    f += 0.0625 * noise(p);
    return f / 0.9375;
}

// Stars background
vec3 nmzHash33(vec3 q) {
    uvec3 p = uvec3(ivec3(q));
    p = p * uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;
    p = p.yzx * (p.zxy ^ (p >> 3U));
    return vec3(p ^ (p >> 16U)) * (1.0 / vec3(0xffffffffU));
}

vec3 stars(in vec3 p) {
    vec3 c = vec3(0.);
    float resX = 400.;
    for(float i = 0.; i < 4.; i++) {
        vec3 q = fract(p * (.15 * resX)) - 0.5;
        vec3 id = floor(p * (.15 * resX));
        vec2 rn = nmzHash33(id).xy;
        float c2 = 1. - smoothstep(0., .6, length(q));
        c2 *= step(rn.x, .0005 + i * 0.002);
        c += c2 * (mix(vec3(1.0, 0.49, 0.1), vec3(0.75, 0.9, 1.), rn.y) * 0.25 + 0.75);
        p *= 1.4;
    }
    return c * c * 0.5;
}
`,libsAfterDe=`
vec3 grad(vec3 p) {
    float eps = 0.01;
    return normalize(vec3(
        (de(p + vec3(eps, 0., 0.)) - de(p - vec3(eps, 0., 0.))) / (2. * eps),
        (de(p + vec3(0., eps, 0.)) - de(p - vec3(0., eps, 0.))) / (2. * eps),
        (de(p + vec3(0., 0., eps)) - de(p - vec3(0., 0., eps))) / (2. * eps)
    ));
}

float ao(vec3 p, vec3 n) {
    float occ = 0.0;
    float sca = 1.0;
    for(int i = 0; i < 5; i++) {
        float h = 0.01 + 0.12 * float(i) / 4.0;
        float d = de(p + h * n);
        occ += (h - d) * sca;
        sca *= 0.95;
    }
    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
}
`;function rotY(e,t){return[e[0]*Math.cos(t)+e[2]*Math.sin(t),e[1],-e[0]*Math.sin(t)+e[2]*Math.cos(t)]}function rotX(e,t){return[e[0],e[1]*Math.cos(t)-e[2]*Math.sin(t),e[1]*Math.sin(t)+e[2]*Math.cos(t)]}function plus(e,t){return[e[0]+t[0],e[1]+t[1],e[2]+t[2]]}function times(e,t){return[e[0]*t,e[1]*t,e[2]*t]}function min(...e){return Math.min(...e)}function max(...e){return Math.max(...e)}function abs(e){return Array.isArray(e)?e.map(Math.abs):e<0?-e:e}function cos(e){return Array.isArray(e)?e.map(Math.cos):Math.cos(e)}function sin(e){return Array.isArray(e)?e.map(Math.sin):Math.sin(e)}function len(e){return Math.hypot(...e)}function normalize(e){const t=len(e);return t===0?[0,0,0]:times(e,1/t)}function dot(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function cross(e,t){return[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]]}function reflect(e,t){return plus(e,times(t,-2*dot(e,t)))}function lerp(e,t,n){return Array.isArray(e)?e.map((e,s)=>e+(t[s]-e)*n):e+(t-e)*n}function sinLerp(e,t,n){return lerp(e,t,Math.sin(Math.PI*(n-.5))/2+.5)}function clamp(e,t,n){return Math.min(Math.max(e,t),n)}function I(){return[[1,0,0],[0,1,0],[0,0,1]]}function matTimes(e,t){return[e[0][0]*t[0]+e[0][1]*t[1]+e[0][2]*t[2],e[1][0]*t[0]+e[1][1]*t[1]+e[1][2]*t[2],e[2][0]*t[0]+e[2][1]*t[1]+e[2][2]*t[2]]}function matTimesMat(e,t){let n=[[],[],[]];for(let s=0;s<3;s++){let o=matTimes(e,[t[0][s],t[1][s],t[2][s]]);for(let e=0;e<3;e++)n[e].push(o[e])}return n}function rotAxisMat(e,t){const n=Math.cos(e),s=Math.sin(e);return[[n+t[0]*t[0]*(1-n),t[0]*t[1]*(1-n)-t[2]*s,t[0]*t[2]*(1-n)+t[1]*s],[t[1]*t[0]*(1-n)+t[2]*s,n+t[1]*t[1]*(1-n),t[1]*t[2]*(1-n)-t[0]*s],[t[2]*t[0]*(1-n)-t[1]*s,t[2]*t[1]*(1-n)+t[0]*s,n+t[2]*t[2]*(1-n)]]}function sdBox3(e,t){let n=plus(abs(e),times(t,-1));return len([max(n[0],0),max(n[1],0),max(n[2],0)])+min(max(n[0],n[1],n[2]),0)}function dirFromAngle(e,t){let n=[0,0,1];return n=rotX(n,-t),n=rotY(n,e),n}function getMountainHeight(e,t){const n=t*.3,s=Math.sin(e*.1)*2+Math.sin(t*.05)*3;return Math.max(0,n+s)}function getSlopeAngle(){return Math.atan(.3)}function isOnPath(e){const n=6;return(e<0?-e:e)<n}function deNormal(e){const t=.01;return normalize([de(plus(e,[t,0,0]))-de(plus(e,[-t,0,0])),de(plus(e,[0,t,0]))-de(plus(e,[0,-t,0])),de(plus(e,[0,0,t]))-de(plus(e,[0,0,-t]))])}function getBumpyHeight(e,t){let n=0;if(t>18&&t<30&&(e<0?-e:e)<5){const s=smoothstepJS(18,20,t)*smoothstepJS(30,28,t);n+=Math.sin(e*3)*Math.sin(t*3)*.15*s}if(t>48&&t<60&&(e<0?-e:e)<5){const s=smoothstepJS(48,50,t)*smoothstepJS(60,58,t);n+=Math.sin(e*4+1)*Math.sin(t*4)*.2*s}if(t>93&&t<105&&(e<0?-e:e)<5){const s=smoothstepJS(93,95,t)*smoothstepJS(105,103,t);n+=Math.sin(e*5+2)*Math.sin(t*5)*.18*s}return n}function smoothstepJS(e,t,n){const s=clamp((n-e)/(t-e),0,1);return s*s*(3-2*s)}function getTerrainHeight(e,t){const n=t*.3,s=Math.sin(e*.1)*2+Math.sin(t*.05)*3,o=getBumpyHeight(e,t);return Math.max(-5,n+s+o)}function simpleNoise(e,t){return Math.sin(e*1.3+t*.7)*Math.cos(e*.9-t*1.1)*.5}</script><script>function Animator(e,t){this.uniforms=e,this.interp=t||lerp,this.states=[],this.state=-1,this.stateT=0,this.totalStateT=0,this.stateFrames=[],this.t=0,this.totalAnimTime=0,this.keyFrames=[],this.addKeyFrame=(e,t,n)=>{this.states[n]===0[0]&&(this.states[n]={keyFrames:[],totalAnimTime:0}),this.states[n].keyFrames.push({nodes:e,t}),t>this.states[n].totalAnimTime&&(this.states[n].totalAnimTime=t),this.states.length===1&&(this.keyFrames=this.states[n].keyFrames,this.totalAnimTime=this.states[n].totalAnimTime)},this.currentPos=()=>this.getPos(this.t),this.setState=(e,t)=>{this.state!==e&&(this.state=e,this.t=0,this.stateFrames=[this.getPos(this.t)],this.keyFrames=this.states[e].keyFrames,this.totalAnimTime=this.states[e].totalAnimTime,this.stateT=t,this.totalStateT=t,this.stateFrames.push(this.keyFrames[0].nodes))},this.getPos=e=>{if(this.stateT<=0){if(this.keyFrames.length===1)return this.keyFrames[0].nodes;e%=this.totalAnimTime;let t=0;if(e>this.keyFrames[this.keyFrames.length-2].t)t=this.keyFrames.length-2;else{for(;e>=this.keyFrames[t].t;)t++;t--}let n=[];for(let s in this.keyFrames[t].nodes)n.push(this.interp(this.keyFrames[t].nodes[s],this.keyFrames[t+1].nodes[s],(e-this.keyFrames[t].t)/(this.keyFrames[t+1].t-this.keyFrames[t].t)));return n}this.stateT-=dt;let t=[];for(let e in this.stateFrames[0])t.push(this.interp(this.stateFrames[0][e],this.stateFrames[1][e],1-this.stateT/this.totalStateT));return this.t=0,t},this.update=()=>{this.t+=dt;let e=this.getPos(this.t);for(let t in this.uniforms)renderer.setUni(this.uniforms[t],e[t])}}</script><script>function createGraphics(e,t,n,s){let i=document.createElement("canvas"),c=1;i.width=c*window.innerWidth,i.height=c*window.innerHeight,document.body.appendChild(i),i.onclick=()=>i.requestPointerLock();let o=i.getContext("webgl2");function r(e,t){let n=o.createShader(t);if(o.shaderSource(n,e),o.compileShader(n),o.getShaderParameter(n,o.COMPILE_STATUS))return n;console.log(o.getShaderInfoLog(n)),o.deleteShader(n)}function d(e,t){let n=o.createProgram();return o.attachShader(n,e),o.attachShader(n,t),o.linkProgram(n),n}let u=`#version 300 es
    in vec4 a_position;
    out vec4 pos4;
    void main() {
        pos4 = a_position;
        gl_Position = a_position;
    }`,h=`#version 300 es
    #define MIN_DIST 0.002
    #define MAX_ITERATIONS 120
    #define RANGE 500.

    precision highp float;

    out vec4 color;
    in vec4 pos4;

    uniform vec2 res;
    uniform vec3 camPos;
    uniform vec2 camAngle;
    uniform float t;
    uniform vec3 playerPos;
    uniform vec3 boulderPos;
    uniform mat3 boulderRotMat;
    uniform vec2 playerAngle;
    uniform float isPushing;
    uniform float gameState;
    ${s}

    ${libs}

    ${e}

    ${libsAfterDe}

    ${n}

    void main() {
        vec2 pos = pos4.xy;
        pos.x *= res.x / res.y;

        float fovX = 0.4;
        float fovY = 0.4;

        vec3 dir = normalize(vec3(pos.x * fovX, pos.y * fovY, 0.6));
        dir = rotX(dir, -camAngle.y);
        dir = rotY(dir, camAngle.x);

        vec3 p = camPos;
        float dist = de(p);
        float totDist = dist;
        float glowDist = boulderGlow(p);
        float minGlow = glowDist;

        for(int i = 0; i < MAX_ITERATIONS; i++) {
            if(dist < MIN_DIST || totDist > RANGE) break;
            p += dir * dist;
            dist = de(p);
            glowDist = boulderGlow(p);
            if(glowDist < minGlow) minGlow = glowDist;
            totDist += dist;
        }

        ${t}
    }`,m=r(u,o.VERTEX_SHADER),f=r(h,o.FRAGMENT_SHADER),a=d(m,f),l=o.getAttribLocation(a,"a_position"),p=o.createBuffer();o.bindBuffer(o.ARRAY_BUFFER,p),o.bufferData(o.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,1,1,-1,-1,-1]),o.STATIC_DRAW);let g=o.createVertexArray();return o.bindVertexArray(g),o.enableVertexAttribArray(l),o.vertexAttribPointer(l,2,o.FLOAT,!1,0,0),o.viewport(0,0,i.width,i.height),o.clearColor(0,0,0,0),o.clear(o.COLOR_BUFFER_BIT),o.useProgram(a),{gl:o,program:a,c:i}}function Renderer(e,t,n,s){let o=createGraphics(e,t,n,s);this.gl=o.gl,this.canvas=o.c,this.program=o.program,this.uniforms={},this.addUniform=(e,t,n)=>{Array.isArray(n)&&!Array.isArray(n[0])&&(n=new Float32Array(n));let s={location:"",t,name:e,value:n};s.location=this.gl.getUniformLocation(this.program,e),t==="vec2"&&(s.t=(e,t)=>this.gl.uniform2fv(e,t)),t==="vec3"&&(s.t=(e,t)=>this.gl.uniform3fv(e,t)),t==="vec4"&&(s.t=(e,t)=>this.gl.uniform4fv(e,t)),t==="float"&&(s.t=(e,t)=>this.gl.uniform1f(e,t)),t==="mat3"&&(s.t=(e,t)=>{let n=[];for(let e of t)for(let t of e)n.push(t);this.gl.uniformMatrix3fv(e,!1,new Float32Array(n))}),this.uniforms[e]=s,s.t(s.location,s.value)},this.setUni=(e,t)=>{Array.isArray(t)&&!Array.isArray(t[0])&&(t=new Float32Array(t)),this.uniforms[e].value=t,this.uniforms[e].t(this.uniforms[e].location,t)},this.draw=()=>{this.gl.drawArrays(this.gl.TRIANGLES,0,6)}}</script><script>let renderer=new Renderer(`
// Mountain terrain height - must match JS getTerrainHeight!
float mountainHeight(vec3 p) {
    float baseSlope = p.z * 0.3;
    float wave = sin(p.x * 0.1) * 2.0 + sin(p.z * 0.05) * 3.0;
    float height = baseSlope + wave;
    return max(-5.0, height);
}

// Bumpy sections - adds small bumps in certain areas
float bumpySection(vec3 p) {
    float bumps = 0.0;
    
    // Bumpy zone 1: z = 20-28
    if(p.z > 18.0 && p.z < 30.0 && abs(p.x) < 5.0) {
        float fade = smoothstep(18.0, 20.0, p.z) * smoothstep(30.0, 28.0, p.z);
        bumps += sin(p.x * 3.0) * sin(p.z * 3.0) * 0.15 * fade;
    }
    
    // Bumpy zone 2: z = 50-58
    if(p.z > 48.0 && p.z < 60.0 && abs(p.x) < 5.0) {
        float fade = smoothstep(48.0, 50.0, p.z) * smoothstep(60.0, 58.0, p.z);
        bumps += sin(p.x * 4.0 + 1.0) * sin(p.z * 4.0) * 0.2 * fade;
    }
    
    // Bumpy zone 3: z = 95-103
    if(p.z > 93.0 && p.z < 105.0 && abs(p.x) < 5.0) {
        float fade = smoothstep(93.0, 95.0, p.z) * smoothstep(105.0, 103.0, p.z);
        bumps += sin(p.x * 5.0 + 2.0) * sin(p.z * 5.0) * 0.18 * fade;
    }
    
    return bumps;
}

// The main mountain/ground
float mountain(vec3 p) {
    float h = mountainHeight(p);
    
    // Add visual rocky texture (doesn't affect collision height)
    float rocky = fbm(p * 0.15) * 0.3;
    
    // Add bumpy sections
    float bumps = bumpySection(p);
    
    float ground = p.y - h - rocky - bumps;
    
    // Carve out the path
    float pathWidth = 6.0;
    float pathDepth = 0.5;
    float pathDist = abs(p.x);
    float pathCarve = smoothstep(pathWidth, pathWidth - 1.0, pathDist) * pathDepth;
    
    return ground + pathCarve;
}

// Spinning bar obstacle - tilted to match slope
float spinningBar(vec3 p, vec3 barPos, float barAngle) {
    vec3 q = p - barPos;
    
    // Tilt the whole thing to match the slope (about 16.7 degrees = atan(0.3))
    float slopeAngle = 0.29; // atan(0.3)
    q = rotX(q, slopeAngle);
    q = rotY(q, barAngle);
    
    // Horizontal bar
    float bar = sdCapsule(q, vec3(-4.0, 0.0, 0.0), vec3(4.0, 0.0, 0.0), 0.3);
    // Central pole (perpendicular to slope)
    float pole = sdCylinder(q, 3.0, 0.2);
    
    return min(bar, pole);
}

// Floor beam - small beam lying across the path
float floorBeam(vec3 p, vec3 beamPos, float width) {
    vec3 q = p - beamPos;
    // Tilt to match slope
    q = rotX(q, 0.29);
    // Beam lying across (X direction)
    return sdBox(q, vec3(width, 0.15, 0.3));
}

// Hole/pit in the ground
float hole(vec3 p, vec3 holePos, float radius) {
    vec2 d = vec2(length(p.xz - holePos.xz) - radius, p.y - holePos.y);
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}

// The boulder with carved grooves like jackrabbit
float boulderRings(vec3 p) {
    float rad = 2.0;
    float ringThickness = 0.2;
    
    vec3 r1P = twist(p, 0.2);
    float ring1 = sdTorus(r1P, vec2(rad, ringThickness));
    
    vec3 r2P = rotY(p, 1.047);
    r2P = twist(r2P, 0.2);
    float ring2 = sdTorus(r2P, vec2(rad, ringThickness));
    
    vec3 r3P = rotY(p, 2.094);
    r3P = twist(r3P, 0.2);
    float ring3 = sdTorus(r3P, vec2(rad, ringThickness));
    
    return min(min(ring1, ring2), ring3);
}

float boulder(vec3 p) {
    if(length(p - boulderPos) > 4.0) {
        return sdSphere(p - boulderPos, 2.5);
    }
    vec3 q = p - boulderPos;
    q = boulderRotMat * q;
    
    float sphere = sdSphere(q, 2.5);
    float rings = boulderRings(q);
    
    return max(sphere, -rings);
}

float boulderSimple(vec3 p) {
    return sdSphere(p - boulderPos, 2.5);
}

// Sisyphus character
float playerHead(vec3 p) {
    p -= uHeadPos;
    float head = sdSphere(p - vec3(0.0, 0.4, 0.0), 0.2);
    float nose = sdSphere(p - vec3(0.0, 0.37, 0.18), 0.08);
    
    // Beard
    float beard = sdRoundCone(p, vec3(0.0, 0.25, 0.1), vec3(0.0, 0.1, 0.05), 0.12, 0.08);
    
    float d = smin(head, nose, 0.1);
    d = smin(d, beard, 0.08);
    return d;
}

float playerBody(vec3 p) {
    vec3 chestP = p + uChestPos;
    float torso = sdRoundCone(chestP, vec3(0.0, 0.15, 0.0), vec3(0.0, -0.15, -0.1), 0.2, 0.12);
    
    // Arms extended forward for pushing
    float pushOffset = isPushing * 0.15;
    vec3 armR = vec3(0.15, 0.1 - pushOffset, 0.2 + pushOffset);
    vec3 armL = vec3(-0.15, 0.1 - pushOffset, 0.2 + pushOffset);
    
    float rArm = sdCapsule(chestP, vec3(0.2, 0.1, 0.0), armR, 0.05);
    float lArm = sdCapsule(chestP, vec3(-0.2, 0.1, 0.0), armL, 0.05);
    
    float d = torso;
    d = min(d, rArm);
    d = min(d, lArm);
    return d;
}

float playerLegs(vec3 p) {
    vec3 hip1 = uhip1;
    vec3 jr1 = ujr1;
    vec3 jr2 = ujr2;
    vec3 jr3 = ujr3;
    vec3 hip2 = uhip2;
    vec3 jl1 = ujl1;
    vec3 jl2 = ujl2;
    vec3 jl3 = ujl3;

    float thigh1 = sdCapsule(p, hip1, jr1, 0.04);
    float shin1 = sdCapsule(p, jr1, jr2, 0.035);
    float foot1 = sdCapsule(p, jr2, jr3, 0.03);

    float thigh2 = sdCapsule(p, hip2, jl1, 0.04);
    float shin2 = sdCapsule(p, jl1, jl2, 0.035);
    float foot2 = sdCapsule(p, jl2, jl3, 0.03);

    float d = min(thigh1, shin1);
    d = min(d, foot1);
    d = min(d, thigh2);
    d = min(d, shin2);
    d = min(d, foot2);
    return d;
}

float player(vec3 p) {
    vec3 q = p - playerPos;
    if(length(q) > 1.5) {
        return sdSphere(q, 1.0);
    }
    q = rotY(q, -playerAngle.x);
    
    vec3 bodyP = rotX(q, uBodyAngle.y);
    
    float head = playerHead(bodyP);
    float body = playerBody(bodyP);
    float legs = playerLegs(q);
    
    return min(min(head, body), legs);
}

// All spinning bars - aligned with terrain
float allSpinningBars(vec3 p) {
    float d = 1000.0;
    
    // Bar 1 at z=30
    float h1 = mountainHeight(vec3(0.0, 0.0, 30.0)) + 1.5;
    d = min(d, spinningBar(p, vec3(0.0, h1, 30.0), t * 1.5));
    
    // Bar 2 at z=60
    float h2 = mountainHeight(vec3(0.0, 0.0, 60.0)) + 1.5;
    d = min(d, spinningBar(p, vec3(0.0, h2, 60.0), -t * 2.0));
    
    // Bar 3 at z=90
    float h3 = mountainHeight(vec3(0.0, 0.0, 90.0)) + 1.5;
    d = min(d, spinningBar(p, vec3(0.0, h3, 90.0), t * 1.2 + 1.57));
    
    // Bar 4 at z=120
    float h4 = mountainHeight(vec3(0.0, 0.0, 120.0)) + 1.5;
    d = min(d, spinningBar(p, vec3(0.0, h4, 120.0), -t * 1.8 + 0.785));
    
    return d;
}

// All holes - aligned with terrain
float allHoles(vec3 p) {
    float d = 1000.0;
    
    // Hole 1
    float h1 = mountainHeight(vec3(2.5, 0.0, 45.0)) - 5.0;
    vec3 holePos1 = vec3(2.5, h1, 45.0);
    float hole1 = length(p.xz - holePos1.xz) - 3.0;
    if(p.y < holePos1.y + 5.0) {
        d = min(d, max(hole1, -(p.y - holePos1.y)));
    }
    
    // Hole 2
    float h2 = mountainHeight(vec3(-2.0, 0.0, 75.0)) - 5.0;
    vec3 holePos2 = vec3(-2.0, h2, 75.0);
    float hole2 = length(p.xz - holePos2.xz) - 2.5;
    if(p.y < holePos2.y + 5.0) {
        d = min(d, max(hole2, -(p.y - holePos2.y)));
    }
    
    // Hole 3
    float h3 = mountainHeight(vec3(1.5, 0.0, 105.0)) - 5.0;
    vec3 holePos3 = vec3(1.5, h3, 105.0);
    float hole3 = length(p.xz - holePos3.xz) - 2.0;
    if(p.y < holePos3.y + 5.0) {
        d = min(d, max(hole3, -(p.y - holePos3.y)));
    }
    
    return d;
}

// Tilted box - aligned with slope
float tiltedBox(vec3 p, vec3 boxPos, vec3 size) {
    vec3 q = p - boxPos;
    q = rotX(q, 0.29); // Tilt to match slope
    return sdBox(q, size);
}

// Random boxes scattered on the path - tilted to match slope
float allBoxes(vec3 p) {
    float d = 1000.0;
    
    // Box 1 - left side at z=15
    vec3 boxPos1 = vec3(-3.0, mountainHeight(vec3(-3.0, 0.0, 15.0)) + 1.0, 15.0);
    d = min(d, tiltedBox(p, boxPos1, vec3(1.0, 1.0, 1.0)));
    
    // Box 2 - right side at z=25
    vec3 boxPos2 = vec3(2.5, mountainHeight(vec3(2.5, 0.0, 25.0)) + 0.75, 25.0);
    d = min(d, tiltedBox(p, boxPos2, vec3(0.75, 0.75, 0.75)));
    
    // Box 3 - center-left at z=40
    vec3 boxPos3 = vec3(-1.5, mountainHeight(vec3(-1.5, 0.0, 40.0)) + 1.2, 40.0);
    d = min(d, tiltedBox(p, boxPos3, vec3(1.2, 1.2, 0.8)));
    
    // Box 4 - right at z=55
    vec3 boxPos4 = vec3(3.5, mountainHeight(vec3(3.5, 0.0, 55.0)) + 0.9, 55.0);
    d = min(d, tiltedBox(p, boxPos4, vec3(0.9, 0.9, 1.1)));
    
    // Box 5 - left at z=70
    vec3 boxPos5 = vec3(-4.0, mountainHeight(vec3(-4.0, 0.0, 70.0)) + 1.5, 70.0);
    d = min(d, tiltedBox(p, boxPos5, vec3(1.5, 1.5, 1.0)));
    
    // Box 6 - center-right at z=85
    vec3 boxPos6 = vec3(1.0, mountainHeight(vec3(1.0, 0.0, 85.0)) + 0.8, 85.0);
    d = min(d, tiltedBox(p, boxPos6, vec3(0.8, 0.8, 0.8)));
    
    // Box 7 - left at z=100
    vec3 boxPos7 = vec3(-2.5, mountainHeight(vec3(-2.5, 0.0, 100.0)) + 1.1, 100.0);
    d = min(d, tiltedBox(p, boxPos7, vec3(1.1, 1.1, 0.9)));
    
    // Box 8 - right at z=115
    vec3 boxPos8 = vec3(4.0, mountainHeight(vec3(4.0, 0.0, 115.0)) + 1.3, 115.0);
    d = min(d, tiltedBox(p, boxPos8, vec3(1.3, 1.0, 1.2)));
    
    // Box 9 - center at z=130
    vec3 boxPos9 = vec3(0.5, mountainHeight(vec3(0.5, 0.0, 130.0)) + 0.7, 130.0);
    d = min(d, tiltedBox(p, boxPos9, vec3(0.7, 0.7, 0.7)));
    
    // Box 10 - left at z=140
    vec3 boxPos10 = vec3(-3.5, mountainHeight(vec3(-3.5, 0.0, 140.0)) + 1.0, 140.0);
    d = min(d, tiltedBox(p, boxPos10, vec3(1.0, 1.0, 1.0)));
    
    return d;
}

// Floor beams - small obstacles on the ground
float allFloorBeams(vec3 p) {
    float d = 1000.0;
    
    // Beam 1 at z=10
    vec3 beamPos1 = vec3(0.0, mountainHeight(vec3(0.0, 0.0, 10.0)) + 0.15, 10.0);
    d = min(d, floorBeam(p, beamPos1, 4.0));
    
    // Beam 2 at z=35
    vec3 beamPos2 = vec3(-1.0, mountainHeight(vec3(-1.0, 0.0, 35.0)) + 0.15, 35.0);
    d = min(d, floorBeam(p, beamPos2, 3.5));
    
    // Beam 3 at z=52
    vec3 beamPos3 = vec3(1.5, mountainHeight(vec3(1.5, 0.0, 52.0)) + 0.15, 52.0);
    d = min(d, floorBeam(p, beamPos3, 3.0));
    
    // Beam 4 at z=68
    vec3 beamPos4 = vec3(0.0, mountainHeight(vec3(0.0, 0.0, 68.0)) + 0.15, 68.0);
    d = min(d, floorBeam(p, beamPos4, 4.5));
    
    // Beam 5 at z=82
    vec3 beamPos5 = vec3(-0.5, mountainHeight(vec3(-0.5, 0.0, 82.0)) + 0.15, 82.0);
    d = min(d, floorBeam(p, beamPos5, 3.5));
    
    // Beam 6 at z=98
    vec3 beamPos6 = vec3(0.5, mountainHeight(vec3(0.5, 0.0, 98.0)) + 0.15, 98.0);
    d = min(d, floorBeam(p, beamPos6, 4.0));
    
    // Beam 7 at z=112
    vec3 beamPos7 = vec3(-1.0, mountainHeight(vec3(-1.0, 0.0, 112.0)) + 0.15, 112.0);
    d = min(d, floorBeam(p, beamPos7, 3.0));
    
    // Beam 8 at z=125
    vec3 beamPos8 = vec3(0.0, mountainHeight(vec3(0.0, 0.0, 125.0)) + 0.15, 125.0);
    d = min(d, floorBeam(p, beamPos8, 5.0));
    
    return d;
}

float boulderGlow(vec3 p) {
    return boulderSimple(p);
}

float de(vec3 p) {
    float ground = mountain(p);
    
    // Carve holes into ground
    float holes = allHoles(p);
    ground = max(ground, -holes);
    
    float bars = allSpinningBars(p);
    float boxes = allBoxes(p);
    float beams = allFloorBeams(p);
    float bould = boulder(p);
    float plyr = player(p);
    
    float d = ground;
    d = min(d, bars);
    d = min(d, boxes);
    d = min(d, beams);
    d = min(d, bould);
    d = min(d, plyr);
    
    return d;
}
`,`
vec3 col = vec3(0.0);
vec3 skyCol = vec3(0.02, 0.01, 0.05);

if(dist <= MIN_DIST) {
    vec3 norm = grad(p);
    float occ = ao(p, norm);
    
    vec3 lightDir = normalize(vec3(0.5, 0.8, -0.3));
    vec3 lightDir2 = normalize(vec3(-0.3, 0.5, 0.5));
    float diff = max(dot(norm, lightDir), 0.0);
    float diff2 = max(dot(norm, lightDir2), 0.0) * 0.3;
    
    // Mountain/ground
    if(mountain(p) < 0.01) {
        vec3 rockCol = vec3(0.25, 0.2, 0.18);
        float n = fbm(p * 2.0);
        rockCol = mix(rockCol, vec3(0.35, 0.3, 0.25), n);
        
        // Path is slightly different color
        float pathGlow = smoothstep(6.0, 4.0, abs(p.x));
        rockCol = mix(rockCol, vec3(0.4, 0.35, 0.3), pathGlow * 0.3);
        
        col = rockCol * (0.3 + diff * 0.5 + diff2) * occ;
        
        // Height-based fog
        float heightFog = smoothstep(0.0, 50.0, p.y);
        col = mix(col, col * vec3(0.8, 0.85, 1.0), heightFog * 0.3);
    }
    
    // Spinning bars
    else if(allSpinningBars(p) < 0.01) {
        vec3 metalCol = vec3(0.6, 0.55, 0.5);
        float spec = pow(max(dot(reflect(-lightDir, norm), normalize(camPos - p)), 0.0), 32.0);
        col = metalCol * (0.4 + diff * 0.4) + vec3(spec * 0.3);
        
        // Danger glow
        col += vec3(0.8, 0.2, 0.1) * (0.2 + 0.1 * sin(t * 5.0));
    }
    
    // Boxes
    else if(allBoxes(p) < 0.01) {
        // Weathered stone/wood color
        vec3 boxCol = vec3(0.45, 0.38, 0.32);
        float n = noise(p * 5.0);
        boxCol = mix(boxCol, vec3(0.55, 0.48, 0.4), n);
        
        // Edge highlighting
        float edgeFactor = 1.0 - smoothstep(0.0, 0.1, allBoxes(p + norm * 0.05));
        boxCol += vec3(0.1) * edgeFactor;
        
        col = boxCol * (0.4 + diff * 0.5 + diff2 * 0.2) * occ;
    }
    
    // Floor beams
    else if(allFloorBeams(p) < 0.01) {
        // Dark wood color
        vec3 woodCol = vec3(0.3, 0.22, 0.15);
        float woodGrain = sin(p.x * 20.0 + noise(p * 3.0) * 5.0) * 0.5 + 0.5;
        woodCol = mix(woodCol, vec3(0.4, 0.3, 0.2), woodGrain * 0.3);
        
        col = woodCol * (0.5 + diff * 0.4) * occ;
    }
    
    // Boulder
    else if(boulder(p) < 0.01) {
        vec3 q = p - boulderPos;
        q = boulderRotMat * q;
        
        vec3 stoneCol = vec3(0.5, 0.45, 0.4);
        float n = fbm(q * 0.5);
        stoneCol = mix(stoneCol, vec3(0.6, 0.55, 0.5), n);
        
        col = stoneCol * (0.4 + diff * 0.5 + diff2 * 0.3) * occ;
        
        // Ring grooves glow
        float ringDist = boulderRings(q);
        if(ringDist < 0.5) {
            col += vec3(0.9, 0.7, 0.3) * (0.5 - ringDist) * (0.5 + 0.5 * sin(t * 2.0));
        }
        
        // Glow when being pushed
        col += vec3(0.8, 0.6, 0.2) * isPushing * 0.3;
    }
    
    // Player (Sisyphus)
    else if(player(p) < 0.01) {
        vec3 q = p - playerPos;
        q = rotY(q, -playerAngle.x);
        vec3 bodyP = rotX(q, uBodyAngle.y);
        
        // Skin tone for Sisyphus
        vec3 skinCol = vec3(0.7, 0.55, 0.45);
        
        if(playerHead(bodyP) < 0.01) {
            col = skinCol * (0.5 + diff * 0.4);
            // Eyes
            float eyeR = sdSphere(bodyP - uHeadPos - vec3(0.08, 0.45, 0.12), 0.03);
            float eyeL = sdSphere(bodyP - uHeadPos - vec3(-0.08, 0.45, 0.12), 0.03);
            if(min(eyeR, eyeL) < 0.01) {
                col = vec3(0.1);
            }
        }
        else if(playerBody(bodyP) < 0.01) {
            // Simple cloth/toga
            vec3 clothCol = vec3(0.75, 0.7, 0.6);
            col = clothCol * (0.4 + diff * 0.5);
            
            // Strain effect when pushing
            col = mix(col, vec3(0.8, 0.5, 0.4), isPushing * 0.2);
        }
        else {
            // Legs - skin
            col = skinCol * (0.5 + diff * 0.4);
        }
    }
    
    // Distance fog
    float fog = 1.0 - exp(-totDist * 0.003);
    col = mix(col, skyCol, fog);
    
} else {
    // Sky with stars
    col = stars(dir) + skyCol;
    
    // Subtle gradient
    col += vec3(0.1, 0.05, 0.15) * (1.0 - abs(dir.y));
}

// Boulder glow bloom effect
float glowIntensity = 0.4 / (1.0 + minGlow * minGlow * 0.5);
col += vec3(0.9, 0.7, 0.3) * glowIntensity * 0.15;

// Vignette
vec2 uv = pos4.xy;
float vig = 1.0 - 0.3 * length(uv);
col *= vig;

// Tone mapping
col = col / (1.0 + col);
col = pow(col, vec3(0.9));

color = vec4(col, 1.0);
`,`
`,`
uniform vec3 uhip1;
uniform vec3 ujr1;
uniform vec3 ujr2;
uniform vec3 ujr3;
uniform vec3 uhip2;
uniform vec3 ujl1;
uniform vec3 ujl2;
uniform vec3 ujl3;
uniform vec3 uChestPos;
uniform vec3 uHeadPos;
uniform float uLift;
uniform vec3 uBodyAngle;
`);const boxObstacles=[{x:-3,z:15,sx:1,sy:1,sz:1},{x:2.5,z:25,sx:.75,sy:.75,sz:.75},{x:-1.5,z:40,sx:1.2,sy:1.2,sz:.8},{x:3.5,z:55,sx:.9,sy:.9,sz:1.1},{x:-4,z:70,sx:1.5,sy:1.5,sz:1},{x:1,z:85,sx:.8,sy:.8,sz:.8},{x:-2.5,z:100,sx:1.1,sy:1.1,sz:.9},{x:4,z:115,sx:1.3,sy:1,sz:1.2},{x:.5,z:130,sx:.7,sy:.7,sz:.7},{x:-3.5,z:140,sx:1,sy:1,sz:1}],floorBeams=[{x:0,z:10,width:4},{x:-1,z:35,width:3.5},{x:1.5,z:52,width:3},{x:0,z:68,width:4.5},{x:-.5,z:82,width:3.5},{x:.5,z:98,width:4},{x:-1,z:112,width:3},{x:0,z:125,width:5}];function de(e){const n=getTerrainHeight(e[0],e[2]);let t=e[1]-n;const s=deSpinningBars(e),o=deBoxes(e),i=deFloorBeams(e),a=deHoles(e);return t=Math.max(t,-a),Math.min(t,Math.min(s,Math.min(o,i)))}function deSpinningBars(e){let n=1/0;const s=[{z:30,speed:1.5,offset:0},{z:60,speed:-2,offset:0},{z:90,speed:1.2,offset:Math.PI/2},{z:120,speed:-1.8,offset:Math.PI/4}];for(const o of s){const a=getTerrainHeight(0,o.z)+1.5,r=[0,a,o.z],c=t*o.speed+o.offset,l=plus(e,times(r,-1)),i=rotY(l,c),d=sdCapsule3D(i,[-4,0,0],[4,0,0],.3),u=sdCylinder3D(i,3,.2);n=Math.min(n,Math.min(d,u))}return n}function deBoxes(e){let t=1/0;for(const n of boxObstacles){const o=getTerrainHeight(n.x,n.z)+n.sy,i=[n.x,o,n.z];let s=plus(e,times(i,-1));s=rotX(s,.29),t=Math.min(t,sdBox3D(s,[n.sx,n.sy,n.sz]))}return t}function deFloorBeams(e){let t=1/0;for(const n of floorBeams){const o=getTerrainHeight(n.x,n.z)+.15,i=[n.x,o,n.z];let s=plus(e,times(i,-1));s=rotX(s,.29),t=Math.min(t,sdBox3D(s,[n.width,.15,.3]))}return t}function sdBox3D(e,t){const n=[Math.abs(e[0])-t[0],Math.abs(e[1])-t[1],Math.abs(e[2])-t[2]],s=len([Math.max(n[0],0),Math.max(n[1],0),Math.max(n[2],0)]),o=Math.min(Math.max(n[0],Math.max(n[1],n[2])),0);return s+o}function deHoles(e){let t=1/0;const n=[{x:2.5,z:45,radius:3},{x:-2,z:75,radius:2.5},{x:1.5,z:105,radius:2}];for(const s of n){const o=getTerrainHeight(s.x,s.z)-5,i=e[0]-s.x,a=e[2]-s.z,r=Math.sqrt(i*i+a*a)-s.radius;e[1]<o+5&&(t=Math.min(t,Math.max(r,-(e[1]-o))))}return t}function sdCapsule3D(e,t,n,s){const i=plus(e,times(t,-1)),o=plus(n,times(t,-1)),a=clamp(dot(i,o)/dot(o,o),0,1);return len(plus(i,times(o,-a)))-s}function sdCylinder3D(e,t,n){const s=[len([e[0],e[2]])-n,Math.abs(e[1])-t];return Math.min(Math.max(s[0],s[1]),0)+len([Math.max(s[0],0),Math.max(s[1],0)])}function getSpinningBarForce(e){const n=[{z:30,speed:1.5,offset:0},{z:60,speed:-2,offset:0},{z:90,speed:1.2,offset:Math.PI/2},{z:120,speed:-1.8,offset:Math.PI/4}];for(const s of n){const i=getTerrainHeight(0,s.z)+1.5,a=[0,i,s.z],o=t*s.speed+s.offset,r=plus(e,times(a,-1)),c=rotY(r,o),l=sdCapsule3D(c,[-4,0,0],[4,0,0],.3);if(l<1){const t=rotY([0,0,1],o+Math.PI/2),e=times(t,s.speed*15);return e[1]=10,{hit:!0,force:e}}}return{hit:!1,force:[0,0,0]}}const holePositions=[{x:2.5,z:45,radius:3},{x:-2,z:75,radius:2.5},{x:1.5,z:105,radius:2}];function isOverHole(e,t){for(const n of holePositions){const s=e-n.x,o=t-n.z,i=Math.sqrt(s*s+o*o);if(i<n.radius)return!0}return!1}function getHoleInfo(e,t){for(const n of holePositions){const s=e-n.x,o=t-n.z,i=Math.sqrt(s*s+o*o);if(i<n.radius*1.5)return n}return null}</script><script>let mouseDown=[],keyDown=[],keyPressed=[];document.onmousemove=e=>{if(document.pointerLockElement){let t=[1/700,1/700];player.angle[0]+=e.movementX*t[0],player.angle[1]-=e.movementY*t[1],player.angle[1]=clamp(player.angle[1],-Math.PI/2.5,Math.PI/2.5)}},document.onmousedown=e=>mouseDown[e.button]=!0,document.onmouseup=e=>mouseDown[e.button]=!1,document.onkeydown=e=>{keyDown[e.key.toLowerCase()]=!0,keyPressed[e.key.toLowerCase()]=!0},document.onkeyup=e=>keyDown[e.key.toLowerCase()]=!1;function Player(){this.pos=[0,2,-10],this.camPos=[0,0,0],this.angle=[0,0],this.bodyAngle=[0,0],this.gravity=40,this.jumpVel=12,this.speed=5,this.pushSpeed=3,this.velocity=[0,0,0],this.body2=.5,this.isPushing=!1,this.pushCooldown=0,this.coyoteTime=0,this.update=()=>{this.checkSpinningBars(),this.move(),this.push(),this.legAnimator&&this.legAnimator.update(),this.updateUniforms()},this.checkSpinningBars=()=>{const e=getSpinningBarForce(this.pos);e.hit&&(this.velocity=plus(this.velocity,e.force),showMessage("Knocked off!",1500))},this.move=()=>{let e=[0,0,0],d=this.isPushing?this.pushSpeed:this.speed;if(keyDown.w&&(e[2]+=Math.cos(this.angle[0]),e[0]+=Math.sin(this.angle[0])),keyDown.s&&(e[2]-=Math.cos(this.angle[0]),e[0]-=Math.sin(this.angle[0])),keyDown.a&&(e[2]+=Math.sin(this.angle[0]),e[0]-=Math.cos(this.angle[0])),keyDown.d&&(e[2]-=Math.sin(this.angle[0]),e[0]+=Math.cos(this.angle[0])),len(e)>0){const t=Math.atan2(e[0],e[2]);this.bodyAngle[0]=lerpAngle(this.bodyAngle[0],t,.1),renderer.setUni("playerAngle",[this.bodyAngle[0],0])}this.onGround()?len(e)>0?this.legAnimator&&this.legAnimator.setState(0,.1):this.legAnimator&&this.legAnimator.setState(1,.2):this.velocity[1]>5?this.legAnimator&&this.legAnimator.setState(2,.1):this.legAnimator&&this.legAnimator.setState(3,1),len(e)>0&&(e=times(normalize(e),d*dt)),this.coyoteTime-=dt,this.onGround()&&(this.coyoteTime=.15,this.velocity[0]*=.9,this.velocity[2]*=.9),keyPressed[" "]&&this.coyoteTime>0&&(this.velocity[1]=this.jumpVel,this.coyoteTime=-1),this.velocity[1]-=this.gravity*dt,e=plus(times(this.velocity,dt),e),this.pos=plus(e,this.pos);const n=isOverHole(this.pos[0],this.pos[2]),s=getTerrainHeight(this.pos[0],this.pos[2]),o=s+this.body2;if(!n&&this.pos[1]<o&&(this.pos[1]=o,this.velocity[1]<0&&(this.velocity[1]=0)),n){const e=getHoleInfo(this.pos[0],this.pos[2]);if(e){const n=e.x-this.pos[0],s=e.z-this.pos[2],t=3;this.velocity[0]+=n*t*dt,this.velocity[2]+=s*t*dt}}const i=deSpinningBars(this.pos);if(i<this.body2){const e=deNormal(this.pos);this.pos=plus(this.pos,times(e,this.body2-i))}const a=deBoxes(this.pos);if(a<this.body2){const e=.05,t=normalize([deBoxes(plus(this.pos,[e,0,0]))-deBoxes(plus(this.pos,[-e,0,0])),deBoxes(plus(this.pos,[0,e,0]))-deBoxes(plus(this.pos,[0,-e,0])),deBoxes(plus(this.pos,[0,0,e]))-deBoxes(plus(this.pos,[0,0,-e]))]);this.pos=plus(this.pos,times(t,this.body2-a));const n=dot(this.velocity,t);n<0&&(this.velocity=plus(this.velocity,times(t,-n)))}const u=deFloorBeams(this.pos);u<this.body2&&(this.pos[1]=Math.max(this.pos[1],getTerrainHeight(this.pos[0],this.pos[2])+.3+this.body2));const r=plus(this.pos,times(boulder.pos,-1)),t=len(r),c=this.body2+boulder.size;if(t<c&&t>.01){const e=normalize(r),s=c-t;this.pos=plus(this.pos,times(e,s));const n=dot(this.velocity,times(e,-1));n>0&&(this.velocity=plus(this.velocity,times(e,n)))}const l=6.5;Math.abs(this.pos[0])>l&&(this.pos[0]=Math.sign(this.pos[0])*l,this.velocity[0]*=-.5),this.pos[1]<s-8&&triggerRestart("Fell into the abyss!")},this.push=()=>{this.pushCooldown-=dt;const e=plus(boulder.pos,times(this.pos,-1)),t=len(e),n=dirFromAngle(this.angle[0],0),s=dot(normalize(e),n),o=t<4.5&&t>2&&s>.5&&keyDown.w&&this.onGround();if(o&&this.pushCooldown<=0){this.isPushing=!0;const t=normalize([e[0],0,e[2]]),n=3;boulder.applyPush(times(t,n)),renderer.setUni("uBodyAngle",[0,.3,0])}else this.isPushing=!1,renderer.setUni("uBodyAngle",[0,0,0]);renderer.setUni("isPushing",this.isPushing?1:0)},this.onGround=()=>{if(isOverHole(this.pos[0],this.pos[2]))return!1;const e=getTerrainHeight(this.pos[0],this.pos[2]);return this.pos[1]<=e+this.body2+.1},this.updateUniforms=()=>{renderer.setUni("playerPos",this.pos),renderer.setUni("camAngle",this.angle);let e=[0,0,-6];e=rotX(e,-this.angle[1]),e=rotY(e,this.angle[0]);let t=plus(plus(this.pos,[0,1.5,0]),e),n=50;for(;de(t)<.8&&n>0;)n--,t=plus(t,times(normalize(e),-.1));renderer.setUni("camPos",t),this.camPos=t},this.reset=e=>{const t=getTerrainHeight(0,e);this.pos=[0,t+2,e],this.velocity=[0,0,0],this.isPushing=!1},this.createAnimators=()=>{const t=["uhip1","ujr1","ujr2","ujr3","uhip2","ujl1","ujl2","ujl3","uHeadPos","uChestPos","uBodyAngle"],e=[[[.1,-.1,-.12],[.15,-.2,.15],[.13,-.35,0],[.13,-.46,.15],[-.1,-.1,-.12],[-.15,-.28,-.05],[-.13,-.3,-.2],[-.13,-.46,-.15],[0,0,0],[0,0,0],[0,-.3,0],1.2],[[.1,-.1,-.12],[.15,-.26,.05],[.13,-.35,-.15],[.13,-.46,0],[-.1,-.1,-.12],[-.15,-.26,.05],[-.13,-.35,-.15],[-.13,-.46,0],[0,0,0],[0,0,0],[0,0,0],1.2],[[.1,-.1,-.12],[.15,-.18,.05],[.13,-.25,-.15],[.13,-.35,0],[-.1,-.1,-.12],[-.15,-.18,.05],[-.13,-.25,-.15],[-.13,-.35,0],[0,0,0],[0,0,0],[0,-.2,0],1.2],[[.1,-.1,-.12],[.15,-.13,.05],[.13,-.2,-.15],[.13,-.3,0],[-.1,-.1,-.12],[-.15,-.13,.05],[-.13,-.2,-.15],[-.13,-.3,0],[0,0,0],[0,0,0],[0,-.2,0],1.2],[[.1,-.1,-.12],[.15,-.28,-.05],[.13,-.3,-.2],[.13,-.46,-.15],[-.1,-.1,-.12],[-.15,-.2,.15],[-.13,-.35,0],[-.13,-.46,.15],[0,0,0],[0,0,0],[0,-.3,0],1.2]];for(let n in t)renderer.addUniform(t[n],"vec3",e[1][n]);renderer.addUniform("uLift","float",1.2),this.legAnimator=new Animator([...t,"uLift"],sinLerp);const n=.3;this.legAnimator.addKeyFrame(e[0],0,0),this.legAnimator.addKeyFrame(e[4],n/2,0),this.legAnimator.addKeyFrame(e[0],n,0),this.legAnimator.addKeyFrame(e[1],0,1),this.legAnimator.addKeyFrame(e[2],0,2),this.legAnimator.addKeyFrame(e[3],0,3)},this.createAnimators()}function lerpAngle(e,t,n){return e=e%(2*Math.PI),t=t%(2*Math.PI),Math.abs(t-e)<Math.PI?lerp(e,t,n):(e+=Math.sign(t-e)*2*Math.PI,lerp(e,t,n))}let player=new Player</script><script>function Boulder(){this.pos=[0,5,0],this.size=2.5,this.gravity=25,this.velocity=[0,0,0],this.rotVel=0,this.rotAxis=[0,0,1],this.rotMat=I(),this.friction=.98,this.groundFriction=.995,this.slopeGravity=12,this.beingPushed=!1,this.pushForce=[0,0,0],this.maxHeight=0,this.update=()=>{this.beingPushed=len(this.pushForce)>.1,this.beingPushed&&(this.velocity=plus(this.velocity,times(this.pushForce,dt)),this.pushForce=times(this.pushForce,.9)),this.checkBarCollision(),this.checkHoles();const o=getTerrainHeight(this.pos[0],this.pos[2]),e=o+this.size;if(this.pos[1]<=e+.1){if(this.pos[1]=e,this.velocity[1]<-5?this.velocity[1]*=-.3:this.velocity[1]=0,this.velocity[0]*=this.groundFriction,this.velocity[2]*=this.groundFriction,!this.beingPushed&&this.pos[2]>0){const e=this.slopeGravity*.3;this.velocity[2]-=e*dt,this.velocity[0]+=(Math.random()-.5)*.5*dt}const t=len([this.velocity[0],this.velocity[2]]);t>.1&&(this.rotVel=t/this.size,this.rotAxis=normalize(cross([this.velocity[0],0,this.velocity[2]],[0,1,0])))}else this.velocity[1]-=this.gravity*dt;this.velocity=times(this.velocity,this.friction),this.pos=plus(this.pos,times(this.velocity,dt));const t=deBoxes(this.pos);if(t<this.size){const e=.1,n=normalize([deBoxes(plus(this.pos,[e,0,0]))-deBoxes(plus(this.pos,[-e,0,0])),deBoxes(plus(this.pos,[0,e,0]))-deBoxes(plus(this.pos,[0,-e,0])),deBoxes(plus(this.pos,[0,0,e]))-deBoxes(plus(this.pos,[0,0,-e]))]);this.pos=plus(this.pos,times(n,this.size-t+.1));const s=dot(this.velocity,n);s<0&&(this.velocity=plus(this.velocity,times(n,-s*1.5)))}const n=deFloorBeams(this.pos);if(n<this.size){const e=.1,t=normalize([deFloorBeams(plus(this.pos,[e,0,0]))-deFloorBeams(plus(this.pos,[-e,0,0])),deFloorBeams(plus(this.pos,[0,e,0]))-deFloorBeams(plus(this.pos,[0,-e,0])),deFloorBeams(plus(this.pos,[0,0,e]))-deFloorBeams(plus(this.pos,[0,0,-e]))]);this.pos=plus(this.pos,times(t,this.size-n+.05)),this.velocity[1]+=2,this.velocity[2]*=.9}const s=5.5;Math.abs(this.pos[0])>s&&(this.pos[0]=Math.sign(this.pos[0])*s,this.velocity[0]*=-.5),this.pos[2]<-5&&(this.pos[2]=-5,this.velocity[2]=0),len(this.rotAxis)>0&&(this.rotMat=matTimesMat(rotAxisMat(this.rotVel*dt,this.rotAxis),this.rotMat)),this.pos[2]>this.maxHeight&&(this.maxHeight=this.pos[2]),this.pos[2]<this.maxHeight-30&&this.maxHeight>10&&triggerRestart("The boulder escaped!"),this.updateUniforms()},this.checkBarCollision=()=>{const e=getSpinningBarForce(this.pos);e.hit&&(this.velocity=plus(this.velocity,times(e.force,.5)),this.velocity[1]+=5)},this.checkHoles=()=>{const e=[{x:2.5,z:45,radius:3},{x:-2,z:75,radius:2.5},{x:1.5,z:105,radius:2}];for(const t of e){const s=this.pos[0]-t.x,o=this.pos[2]-t.z,n=Math.sqrt(s*s+o*o);if(n<t.radius+this.size*.5){const e=5*(1-n/(t.radius+this.size));this.velocity[0]-=s/n*e*dt,this.velocity[2]-=o/n*e*dt,n<t.radius*.5&&triggerRestart("The boulder fell into a pit!")}}},this.applyPush=e=>{this.pushForce=plus(this.pushForce,e)},this.updateUniforms=()=>{renderer.setUni("boulderPos",this.pos),renderer.setUni("boulderRotMat",this.rotMat)},this.reset=e=>{const t=getTerrainHeight(0,e);this.pos=[0,t+this.size+1,e+3],this.velocity=[0,0,0],this.rotMat=I(),this.rotVel=0,this.maxHeight=e,this.pushForce=[0,0,0]},this.de=e=>len(plus(e,times(this.pos,-1)))-this.size}let boulder=new Boulder</script><script>renderer.addUniform("res","vec2",[window.innerWidth,window.innerHeight]),renderer.addUniform("camPos","vec3",[0,5,-10]),renderer.addUniform("camAngle","vec2",[0,0]),renderer.addUniform("t","float",0),renderer.addUniform("boulderPos","vec3",[0,5,3]),renderer.addUniform("playerPos","vec3",[0,2,0]),renderer.addUniform("playerAngle","vec2",[0,0]),renderer.addUniform("boulderRotMat","mat3",I()),renderer.addUniform("isPushing","float",0),renderer.addUniform("gameState","float",0);let t=performance.now()/1e3,dt=1/60,gameStarted=!1,restartPending=!1,restartMessage="",messageTimeout=null;const titleScreen=document.getElementById("title-screen"),instructions=document.getElementById("instructions"),progressEl=document.getElementById("progress"),messageEl=document.getElementById("message"),resetBtn=document.getElementById("reset-btn"),mobileControls=document.getElementById("mobile-controls"),mobileInstructions=document.getElementById("mobile-instructions"),joystickZone=document.getElementById("joystick-zone"),joystickKnob=document.getElementById("joystick-knob"),lookZone=document.getElementById("look-zone"),jumpBtn=document.getElementById("jump-btn"),isMobile="ontouchstart"in window||navigator.maxTouchPoints>0||window.innerWidth<=768;titleScreen.onclick=()=>{titleScreen.classList.add("hidden"),progressEl.classList.remove("hidden"),instructions.classList.remove("hidden"),resetBtn.classList.remove("hidden"),isMobile&&(mobileControls.classList.remove("hidden"),mobileInstructions.classList.remove("hidden"),lookZone.classList.remove("hidden")),gameStarted=!0,player.reset(-10),boulder.reset(-10),isMobile||renderer.canvas.requestPointerLock()};function fullReset(){restartPending=!1,player.reset(-10),boulder.reset(-10),boulder.maxHeight=0,showMessage("Reset!",1500)}resetBtn.onclick=e=>{e.stopPropagation(),fullReset(),isMobile||renderer.canvas.requestPointerLock()};function showMessage(e,t=2e3){messageEl.textContent=e,messageEl.classList.add("show"),messageTimeout&&clearTimeout(messageTimeout),messageTimeout=setTimeout(()=>{messageEl.classList.remove("show")},t)}function triggerRestart(e){if(restartPending)return;restartPending=!0,restartMessage=e,showMessage(e+" Walk back to the bottom to restart.",5e3),boulder.reset(-5)}function checkRestart(){restartPending&&player.pos[2]<0&&(restartPending=!1,showMessage("Begin again...",2e3),boulder.reset(-5),boulder.maxHeight=0)}function checkVictory(){const e=150;boulder.pos[2]>=e&&(showMessage("Victory! But the boulder rolls back...",4e3),setTimeout(()=>{boulder.reset(-5),player.reset(-10),boulder.maxHeight=0},4e3))}function updateUI(){const e=Math.max(0,Math.floor(boulder.pos[2]*.3)),t=Math.max(0,Math.floor(boulder.maxHeight*.3));progressEl.textContent=`Height: ${e}m (Best: ${t}m)`}function update(){try{const e=performance.now()/1e3;dt=Math.min(e-t,1/20),t=e,gameStarted&&(player.update(),boulder.update(),checkRestart(),checkVictory(),updateUI()),renderer.setUni("t",t),renderer.draw(),keyPressed=[]}catch(e){console.error(e)}requestAnimationFrame(update)}window.onresize=()=>{renderer.canvas.width=window.innerWidth,renderer.canvas.height=window.innerHeight,renderer.gl.viewport(0,0,window.innerWidth,window.innerHeight),renderer.setUni("res",[window.innerWidth,window.innerHeight])},document.addEventListener("pointerlockchange",()=>{!document.pointerLockElement&&gameStarted&&!isMobile&&showMessage("Click to resume",1e3)}),document.addEventListener("keydown",e=>{e.key.toLowerCase()==="r"&&gameStarted&&fullReset()});let joystickActive=!1,joystickTouchId=null,joystickCenter={x:0,y:0},joystickInput={x:0,y:0},lookActive=!1,lookTouchId=null,lookStart={x:0,y:0};function getTouchById(e,t){for(let n=0;n<e.length;n++)if(e[n].identifier===t)return e[n];return null}if(joystickZone){joystickZone.addEventListener("touchstart",e=>{if(e.preventDefault(),joystickTouchId===null){const n=e.changedTouches[0];joystickTouchId=n.identifier,joystickActive=!0;const t=joystickZone.getBoundingClientRect();joystickCenter={x:t.left+t.width/2,y:t.top+t.height/2}}},{passive:!1}),joystickZone.addEventListener("touchmove",e=>{e.preventDefault();const t=getTouchById(e.touches,joystickTouchId);if(t&&joystickActive){const n=t.clientX-joystickCenter.x,s=t.clientY-joystickCenter.y,e=50,o=Math.min(Math.sqrt(n*n+s*s),e),i=Math.atan2(s,n);joystickInput.x=o/e*Math.cos(i),joystickInput.y=o/e*Math.sin(i),joystickKnob.style.left=`calc(50% + ${joystickInput.x*e}px)`,joystickKnob.style.top=`calc(50% + ${joystickInput.y*e}px)`,keyDown.w=joystickInput.y<-.3,keyDown.s=joystickInput.y>.3,keyDown.a=joystickInput.x<-.3,keyDown.d=joystickInput.x>.3}},{passive:!1});const e=e=>{const t=getTouchById(e.changedTouches,joystickTouchId);t&&(joystickActive=!1,joystickTouchId=null,joystickInput={x:0,y:0},joystickKnob.style.left="50%",joystickKnob.style.top="50%",keyDown.w=!1,keyDown.s=!1,keyDown.a=!1,keyDown.d=!1)};joystickZone.addEventListener("touchend",e,{passive:!1}),joystickZone.addEventListener("touchcancel",e,{passive:!1})}if(lookZone){lookZone.addEventListener("touchstart",e=>{if(e.preventDefault(),lookTouchId===null){const t=e.changedTouches[0];lookTouchId=t.identifier,lookActive=!0,lookStart={x:t.clientX,y:t.clientY}}},{passive:!1}),lookZone.addEventListener("touchmove",e=>{e.preventDefault();const t=getTouchById(e.touches,lookTouchId);if(t&&lookActive&&gameStarted){const n=t.clientX-lookStart.x,s=t.clientY-lookStart.y,e=.004;player.angle[0]+=n*e,player.angle[1]-=s*e,player.angle[1]=clamp(player.angle[1],-Math.PI/2.5,Math.PI/2.5),lookStart={x:t.clientX,y:t.clientY}}},{passive:!1});const e=e=>{const t=getTouchById(e.changedTouches,lookTouchId);t&&(lookActive=!1,lookTouchId=null)};lookZone.addEventListener("touchend",e,{passive:!1}),lookZone.addEventListener("touchcancel",e,{passive:!1})}jumpBtn&&(jumpBtn.addEventListener("touchstart",e=>{e.preventDefault(),e.stopPropagation(),jumpBtn.classList.add("active"),keyPressed[" "]=!0,keyDown[" "]=!0},{passive:!1}),jumpBtn.addEventListener("touchend",e=>{e.preventDefault(),jumpBtn.classList.remove("active"),keyDown[" "]=!1},{passive:!1}),jumpBtn.addEventListener("touchcancel",()=>{jumpBtn.classList.remove("active"),keyDown[" "]=!1})),renderer.canvas.addEventListener("touchstart",e=>e.preventDefault(),{passive:!1}),renderer.canvas.addEventListener("touchmove",e=>e.preventDefault(),{passive:!1}),renderer.draw(),update()</script>